#"""
The Command Manifest
--------------------------------------------------

The command manifest defines the commands that can be run in LIMAR. Commands (@command) may be
queries (@query) or actions (@action). All commands are tagged according to the subjects (@subjects)
they fetch data about (for queries) or perform operations on (for actions). Subjects are organised
into a hierarchy called the LIMAR Model. Data about subjects are called entities.

Subjects and Entities
--------------------------------------------------

Subjects are like types or database tables, except that subjects are 'specified', rather than
'static' or 'dynamic'. That means that LIMAR doesn't check what you're doing before it runs commands
based on what you've told it in this manifest (static typing), nor do fetched entities record what
type they are (dynamic typing). Instead, LIMAR interprets entities to contain information about the
subjects you are operating on at the time you operate on them, usually after fetching only the
entities that include the specified subjects.

Entities are like objects, or records in a database. They are composed of 'entity data', which is the
output of each query that matches a subject request, which are then merged to form a list of
entities indexed by the IDs of each subject in the request. If there are multiple subjects in the
request, they will be indexed by a composite key (a tuple) consisting of the IDs of each subject in
the request, in order.

The LIMAR Model
--------------------------------------------------

The LIMAR Model consists of a hierarchy of subjects. The first level of nodes are:

```
/subject  - Subjects (ie. subject metadata).
/hardware - Physical devices that make up agents.
/agent    - Performs actions.
/identity - Determines what actions agents are allowed to perform, and with what requirements.
/process  - Sequences of actions being performed.
/channel  - Routes that processes and agents cooperate to use for the transfer of data within and
            between them.
/data     - Information and compositions of it that determine the sequences of actions for processes
            to perform, and that processes perform actions on.
/change   - Changes to data and other relevant aspects of tracking those changes.
```

The full model is:
===== TODO =========================================================================================
This is static for now, but should be retrievable using manifest commands, or from the `/subject`
subject.
====================================================================================================

```
/subject

/hardware
/agent {
  /passive (hardware? alias: /store)
    > passive-active/attachment
  /active (hardware? alias: /host)
}

/identity (alias: identity and trust, identity and access, iam) {
  /user
  /group
  /role
}

/process (host? installation? configuration? command? identity? alias: proc) {
  /kernel
  /service     (kernel? async operations?)
  /application (kernel? sync operations? alias: app)
  /operation   (kernel? service (optional)? alias: op)

  /process/content {
    # sub-process that depends on and augments a parent process
    /module

    # per-process /configuration ('pushed in')
    /parameter (alias: param)
    # per-process /configuration, cloned from parent process and used as needed ('pulled in'); eg. env vars, current dir, vfs root, etc.
    /environment (alias: env)

    # current state (including status)
    /state
    # historical state
    /log
  }
}

# I/O
/channel {
  # cross-host channel = network I/O (eg. TCP/UDP connections)
  /host {
    /config
  }

  # cross-process channel = I/O (eg. stdin/out/err, keyboard, mouse, IPC)
  /process {
    /config
  }
}

/data (store? path?) {
  # Basic
  # ----------
  /text
  /number
  /time

  # Address of data
  /path
  /url

  # Process Data -> Process transition
  /command

  /email
  /word

  # Compound
  # ----------
  /host/image (project? version?)

  /filesystem (alias: fs)
  /directory (alias: dir)
  /file

  # a collection of related entities
  /project

  # source code, assets, etc.
  /source (project? version?)
  # binaries, archives/packages, bundles, disk images, etc.
  /artifact (project? version?)
  # running instances of an artifact
  /deployment (artifact? alias: instance, installation)
  # parameter and environment bindings for a given deployment
  /configuration (artifact? deployment (optional)? alias: config, conf, cfg)
}

# Versions and Change
# Eg. file history, tagged versions, tasks, (the act of) deployments, etc.
/change {
  /tracker (alias: repo)
  /version {
    /reference (alias: ref)
  }
  /delta
}

# Other stuff (UNCATEGORISED)
/quality # tests, validity, integrity, 7 Cs, etc.
/knowledge # comments, documentation strings, readmes, licencing, design information and visualisations, etc.
```

Self-Classification
--------------------------------------------------

LIMAR differentiates between what a thing *is* and what a thing *operates on*. Tags without a name
represent the *target* entities of the command. Unless overridden, all commands are assumed to be
`is: /process/operation`.
"""

# Tags
# ----------------------------------------------------------------------------------------------------

:__DUPLICATE (description: """Unused because it only contains functionality that another tool has, and the other tool does it better""")
:__OLD (description: """Out of date, and should no longer be used""")
:__TODO (description: """Not fully defined in the manifest yet""")

# Hardware
#   (/hardware)
# ----------------------------------------------------------------------------------------------------

biosdecode (__TODO, hardware) # description of system's bios/uefi
dmidecode  (__TODO, hardware) # description of system's hardware components

# See:
# - https://dassencio.org/75
@tool (
  command: lspci
  description: """List PCI devices."""
) {
  @command(
    command: """lspci -vvmmnn -D"""
  )
  @query (
    parse: """
      gsub("^\\s*|\\s*$"; "")
      | split("\n\n")
      | map(
        [
          split("\n")[]
          | capture("^(?<key>[^:]*):\t(?<value>.*)$")
        ]
        | from_entries
        | {
          id:           (.Slot),

          domain:       (.Slot | split(".")[0] | split(":")[0]),
          bus:          (.Slot | split(".")[0] | split(":")[1]),
          device:       (.Slot | split(".")[0] | split(":")[2]),
          function:     (.Slot | split(".")[1]),

          classId:      (.Class | sub(".* \\[(?<id>[0-9a-f]*)\\]"; "\(.id)")),
          className:    (.Class | sub("(?<name>.*) \\[[0-9a-f]*\\]"; "\(.name)")),
          vendorId:     (.Vendor | sub(".* \\[(?<id>[0-9a-f]*)\\]"; "\(.id)")),
          vendorName:   (.Vendor | sub("(?<name>.*) \\[[0-9a-f]*\\]"; "\(.name)")),
          deviceId:     (.Device | sub(".* \\[(?<id>[0-9a-f]*)\\]"; "\(.id)")),
          deviceName:   (.Device | sub("(?<name>.*) \\[[0-9a-f]*\\]"; "\(.name)")),

          physicalSlot: (.PhySlot),
          revision:     (.Rev)
        }
      )
    """
  )
  lspci/main (hardware, pci)

  @command(
    command: """lspci -vv"""
  )
  @query (
    parse: """
      gsub("^\\s*|\\s*$"; "")
      | split("\n\n")
      | map(
        {
          id: capture("^(?<id>[0-9a-f:\\.]*)").id
        }
        + (
          [
            split("\n")[]
            | capture("^\\t(?<key>[^:]*): (?<value>.*)$")
          ]
          | from_entries
          | {
            control:      .Control,
            status:       .Status,
            latency:      .Latency,
            kernelDriver: ."Kernel driver in use"
          }
        )
      )
    """
  )
  lspci/extras (hardware, pci)
}

# TODO: Finish this off
# See:
# - https://www.google.co.uk/search?q=linux+check+readahead
# - https://www.postgresql.org/message-id/a1ec7d000809111207x3f5aefb9ybc66c556c532084b@mail.gmail.com
# - https://www.google.co.uk/search?q=disk+readahead
# - https://myadventuresincoding.wordpress.com/2020/10/04/cassandra-improving-disk-i-o-by-tuning-readahead/
lsblk (__TODO, hardware)
@tool (
  command: lsblk
  description: """List device, block, partition table, partition, and filesystem information."""
) {
  # Entity Hierarchy:
  #   Device (opt. Partition Table) > Block (opt. Partition) > Filesystem

  @command(
    command: """
      lsblk -a -bDz -Jlo MAJ:MIN,TYPE,PATH,RM,HOTPLUG,WWN,SERIAL,REV,MODEL,VENDOR,TRAN,RQ-SIZE,PHY-SEC,LOG-SEC,MIN-IO,OPT-IO,DISC-ALN,DISC-GRAN,DISC-MAX,DISC-ZERO,RAND
    """
  )
  @query (
    parse: """
      fromjson
      | .blockdevices
      | map(
        select(.type == "disk")
        | {
          # Identity and Relationships
          # This uses the same IDs as blocks, because they cannot be
          # differentiated by kernel ID without assuming too much about the
          # kernel implementation (which is presumably why `lsblk` does not
          # differentiate either).
          id:                 (."maj:min"),
          driverId:           (."maj:min" | split(":")[0]),
          driverBlockId:      (."maj:min" | split(":")[1]),

          # General Info (Optional)
            # If uid is null, then probably not a physical device
          uid:                (.wwn),
          serial:             (.serial),
          revision:           (.rev),
          model:              (.model),
          vendor:             (.vendor),

          # General Technical Info
          filePath:           (.path),

          # Hardware Info
          connectionType:     (.tran),
          isRemovable:        ([.rm, .hotplug] | any),
          isEntropySource:    (.rand),

          # Hardware Sizes
          requestQueueSize:   (."rq-size"),
          physicalSectorSize: (."phy-sec"),
          logicalSectorSize:  (."log-sec"),
          minimumIOSize:      (."min-io"),
          optimalIOSize:      (."opt-io"), # sometimes reports 0

          # Trim (ie. active garbage collection; only some devices)
              # TODO: What does this mean ???
          trimAlignment:      (."disc-aln"),
            # bytes; usually the physical sector size, but can be larger
          trimGranularity:    (."disc-gran"),
            # bytes; maximum unmappable bytes for drive
            # see: https://www.jeffgeerling.com/blog/2020/enabling-trim-on-external-ssd-on-raspberry-pi
          trimMaxBytes:       (."disc-max"),
            # reports if device zero-fills on trim; some filesystems require this
          trimDoesZeroFill:   (."disc-zero"),
        }
      )
    """
  )
  lsblk/device (hardware, device)

  @command(
    command: """
      lsblk -a -bDz -Jlo MAJ:MIN,PTUUID,PTTYPE
    """
  )
  @query (
    parse: """
      fromjson
      | .blockdevices
      | map(
        # Device-to-PartitionTable = 1-to-[0,1]
        # The data is also available on "part"-type blocks, but it is duplicate
        # data - a disk can only have one partition table.
        select(.type == "disk" and .ptuuid != null)
        | {
          # Identity and Relationships
          id:     (."maj:min"),

          # Partition Table
          partitionTable: {
            uid:  (.ptuuid),
            type: (.pttype),
          }
        }
      )
    """
  )
  lsblk/device/partition-table (hardware, device, partition-table)

  @command(
    command: """
      lsblk -a -bDz -Jlo MAJ:MIN,NAME,KNAME,PATH,TYPE,SIZE,RA,ROTA,STATE,RO,OWNER,GROUP,MODE
    """
  )
  @query (
    parse: """
      fromjson
      | .blockdevices
      | map({
        # Identity and Relationships
        id:                (."maj:min"),
        driverId:          (."maj:min" | split(":")[0]),
        driverBlockId:     (."maj:min" | split(":")[1]),

        # General Info
            # Does a block always have a UUID? (some do - see other queries)
        name:              (.name),  # eg. "nvme1n1"
        kernelName:        (.kname), # eg. "nvme1n1" (sometimes != name)
        type:              (.type),  # eg. "loop", "disk", "part"ition

        # Status (optional - disk only)
        state:             (.state), # eg. "running" (HDD), "live" (SSD)

        # Storage Space
        storageSpaceTotal: (.size),

        # Performance
            # not the total size in bytes - it's measured in blocks, but of what size?
        readAheadSize:     (.ra),
        isRotationalDisk:  (.rota),

        # Permissions
        isReadOnly:        (.ro),
        filePath:          (.path),  # eg. "/dev/nvme1n1"
        fileOwner:         (.owner),
        fileGroup:         (.group),
        filePermissions:   (.mode),
      })
    """
  )
  lsblk/block (hardware, block)

  @command(
    command: """
      lsblk -a -bDz -Jlo MAJ:MIN,TYPE,PARTUUID,PARTLABEL,PARTTYPE,PARTTYPENAME,PARTFLAGS
    """
  )
  @query (
    parse: """
      fromjson
      | .blockdevices
      | map(
        # Block-to-Partition = subtype (therefore 1-to-[0,1])
        select(.type == "part")
        | {
          # Identity and Relationships
          id:       (."maj:min"),

          partition: {
            uid:    (.partuuid),
            name:   (.partlabel), # ===== FIXME: if it's a subtype, why does it have two names (or types, etc.)?
                # TODO: needed?
            type:   (.parttypename),
            typeId: (.parttype),
              # Eg. "esp", "boot", "msftres", etc; pttype-specific
            flags:  (.partflags),
          },
        }
      )
    """
  )
  lsblk/block/partition (hardware, block, partition)

  @command(
    command: """
      lsblk -a -bDz -Jlo MAJ:MIN,UUID,LABEL,FSTYPE,FSVER,FSSIZE,FSUSED,FSAVAIL,FSROOTS,MOUNTPOINTS
    """
  )
  @query (
    parse: """
      fromjson
      | .blockdevices
      | map(
        select((.type == "disk" or .type == "part") and .uuid != null)
        | {
          id: (."maj:min" + "/" + .uuid),

          # General
          uid:            (.uuid),
          name:           (.label),
          type:           (.fstype),
          version:        (.fsver),

          # Size (usually - ntfs does not have this for some reason)
          spaceTotal:     (.fssize),
          spaceUsed:      (.fsused),
          spaceAvailable: (.fsavail),

          # Mounts
          # NOTE: The representation of 'none' is changing soon.
          #       See https://github.com/util-linux/util-linux/issues/2871
          # NOTE: They always come in pairs because each 'filesystem' has one.
          #       See https://github.com/util-linux/util-linux/blob/master/libmount/src/fs.c#L1258
          mounts: (
            [
              .fsroots,    # Where on this filesystem is considered the root directory
              .mountpoints # Where in the system filesystem is the root directory of this filesystem attached
            ]
            | transpose
            | map({
              root: .[0],
              mountpoint: .[1]
            })
          ),
        }
      )
    """
  )
  lsblk/filesystem (hardware, filesystem)
}
blkid (__DUPLICATE, hardware, block) # Show block device information. Unnecessary - use `lsblk` instead.

lsusb (__TODO, hardware) # List USB devices

# Agents
#   (/agent)
# ----------------------------------------------------------------------------------------------------

# Network Addresses
#   (/agent/active (aka. /host))
# --------------------

hostname (__TODO, show, host) # show hostname of current host
host     (__TODO, show, host) # resolve DNS records of given hostname

# Data
#   (/data)
# ----------------------------------------------------------------------------------------------------

# General Data: Filesystems, Directories, and Files
# --------------------------------------------------

# Filesystems
#   (/data/filesystem)
# --------------------

# Create and Delete
mkfs         (__TODO, create, filesystem) # create a filesystem of the given type
cryptsetup   (__TODO, create, filesystem) # create and set up a LUKS encrypted filesystem

# Read
mount/show   (__TODO, show,   filesystem) # show info about mounts of a filesystem
df           (__TODO, show,   filesystem) # show filesystem storage space, mounts, etc. info (stands for 'disk filesystem')
fstyp        (__TODO, show,   filesystem) # show filesystem types [only available on some systems; can usually use `mount` for this]
fsck         (__TODO, verify, filesystem) # check filesystem for errors and other issues, and attempt to fix them
# FIXME: Some other commands from `hardware` do this too, eg. lsblk

# Write
growfs       (__TODO, modify, filesystem) # enlarge a ufs filesystem [bsd only]
tune2fs      (__TODO, modify, filesystem) # adjust filesystem parameters [ext2/3/4]
sync         (__TODO, sync,   filesystem) # flush filesystem buffers
mount/attach (__TODO, attach, filesystem) # mount or unmount a filesystem
umount       (__TODO, attach, filesystem) # unmount a filesystem

# Directories and Files
#   (/data/directory, /data/file)
# --------------------

# Create and Delete
mkdir        (__TODO, create,                 dir) # create dir
touch/create (__TODO, create,           file     ) # create file (and set timestamps)
ln           (__TODO, create, symlink,  file     ) # create symbolic link file
mkfifo       (__TODO, create, pipe,     file     ) # create named pipe file
mknod        (__TODO, create, device,   file     ) # create char/block device files & other special files
ar           (__TODO, create, archive,  file     ) # create an archive
tar          (__TODO, create, archive,  file     ) # create a tar archive
zip          (__TODO, create, archive,  file     ) # package and compress files/dirs into zip (`.zip`) file
unzip        (__TODO, create,           file, dir) # decompress and unpackage zip file
gzip         (__TODO, create, archive,  file     ) # package and compress files/dirs into gzip (`.gz`) file
gunzip       (__TODO, create,           file, dir) # decompress and unpackage gzip file
compress     (__TODO, create, archive,  file     ) # compress (gzip?) file or all files in dir recursively (`-r`), adding `.Z` extension
uncompress   (__TODO, create,           file, dir) # uncompress (gzip?) file or all files in dir recursively (`-r`), removing `.Z` extension
rm           (__TODO, delete,           file, dir) # delete file/dir
unlink       (__TODO, delete,           file, dir) # delete file/dir (lower-level version of `rm`) [use `rm` instead]
rmdir        (__TODO, delete,                 dir) # delete an empty dir [use `rm` instead]
shred        (__TODO, delete,           file, dir, secure) # overwrite a file several times to hide its contents

# Read
du           (__TODO, show,             file,      metadata         ) # show file/dir storage space info (stands for 'disk usage')
ls           (__TODO, show,             file, dir, metadata         ) # show file files in a directory and show file attributes
file         (__TODO, show,             file, dir, metadata         ) # show file/dir type
stat         (__TODO, show,             file, dir, metadata         ) # show inode metadata
readlink     (__TODO, show,    symlink, file,                content) # show symbolic link content
cat          (__TODO, show,    text,    file,                content) # concatenate files and output results
tac          (__TODO, show,    text,    file,                content) # cat, then reverses the order of the output [GNU only]
zcat         (__TODO, show,    archive, file,                content) # show contents of gzip compressed file
xzcat        (__TODO, show,    archive, file,                content) # show contents of xz compressed file
bzcat        (__TODO, show,    archive, file,                content) # show contents of bzip compressed file
zzcat        (__TODO, show,    archive, file,                content) # show contents of zip compressed file
less         (__TODO, show,    text,    file,                content, is: app) # view one or more files
more         (__TODO, show,    text,    file,                content, is: app) # view one or more files
find         (__TODO, search,           file, dir, metadata         ) # search for files by name/pattern, attributes, etc. or list files with filters
ff           (__TODO, search,           file, dir, metadata         ) # search for files by name (and others? anywhere on the system; stands for 'find files')
grep         (__TODO, search,           file,                content) # search for files containing patterns
egrep        (__TODO, search,           file,                content) # search for files containing patterns
diff         (__TODO, compare,          file, dir,           content) # compare files
cmp          (__TODO, compare,          file,                content) # compare files byte-by-byte
comm         (__TODO, compare, text,    file,                content) # compare sorted files for common/uncommon lines

# Write
touch/set    (__TODO, set,              file,      metadata         ) # create file (and set timestamps)
chown        (__TODO, set,              file, dir, metadata         ) # set ownership of file/dir
chgrp        (__TODO, set,              file, dir, metadata         ) # set group ownership [use `chown` instead]
chmod        (__TODO, set,              file, dir, metadata         ) # set mode (ie. permissions) of file/dir
truncate     (__TODO, set,              file,                content) # shrink or extend size of file (`-s [+-<>/%]INT([K,M,G,T,P,E,Z,Y][B])`)
patch        (__TODO, set,              file,                content) # apply a diff to a file
tee          (__TODO, set,              file,                content) # both write (overwrite or append) input to a file, and output the input unchanged
ed           (__TODO, show, set, text,  file,                content, is: app) # edit one or more files
nano         (__TODO, show, set, text,  file,                content, is: app) # edit one or more files
vi           (__TODO, show, set, text,  file,                content, is: app) # edit one or more files
vim          (__TODO, show, set, text,  file,                content, is: app) # edit one or more files
emacs        (__TODO, show, set, text,  file,                content, is: app) # edit one or more files
cp           (__TODO, copy,             file, dir, metadata, content) # copy a file/dir
dd           (__TODO, copy,             file,      metadata, content, over: channel/process) # copy (and convert) a file (or dir??) (as a stream) to any other file, including a device file
ftp          (__TODO, copy,             file, dir, metadata, content, over: channel/host) # transfer files/dirs to/from another host using FTP
sftp         (__TODO, copy,             file, dir, metadata, content, over: channel/host) # transfer files/dirs to/from another host using SFTP (FTP + SSL/TLS)
rcp          (__TODO, copy,             file, dir, metadata, content, over: channel/host) # transfer files/dirs to/from another host using RSH (stands for 'remote copy')
scp          (__TODO, copy,             file, dir, metadata, content, over: channel/host) # transfer files/dirs to/from another host using SSH (stands for 'secure copy')
# FIXME: This can copy more than just files - it can copy any HTTP resource
wget         (__TODO, copy,             file, dir, metadata, content, over: channel/host) # fetch a file from another host using HTTP or HTTPS
# FIXME: This can more than just copy files - it can send any HTTP request
curl         (__TODO, copy,             file, dir, metadata, content, over: channel/host) # fetch a file from another host using HTTP or HTTPS
mv           (__TODO, move,             file, dir, metadata, content) # move a file/dir
rsync/local  (__TODO, sync,             file, dir, metadata, content) # sync files/dirs
rsync/remote (__TODO, sync,             file, dir, metadata, content, over: channel/host) # sync files/dirs over the network

# Process Data: Sources, Artifacts, Deployments, and Configurations
#   (/data/source, /data/artifact, /data/deployment, /data/configuration)
# --------------------------------------------------

# FIXME: Every package manager has the following variations:
#create, installation
#delete, installation
#show, package, store, metadata, content
#show, package, metadata
#show, installation, metadata
dpkg         (__TODO, package, installation: global,     configuration) # manage deb packages
apt-get      (__TODO, package, installation: global,     configuration) # manage deb and snap packages
apt-cache    (__TODO, package, installation: global,     configuration) # manage the APT cache
apt          (__TODO, package, installation: global,     configuration) # manage deb packages and the APT chache
aptitute     (__TODO, package, installation: global,     configuration) # manage deb packages
yum          (__TODO, package, installation: global,     configuration) # manage rpm packages
rpm          (__TODO, package, installation: global,     configuration) # manage rpm packages
pacman       (__TODO, package, installation: global,     configuration) # manage tar packages
brew         (__TODO, package, installation: global,     configuration) # manage build scripts ('formulae') and binary packages ('bottles')
flatpak      (__TODO, package, installation: namespaced, configuration) # manage flatpack packages
snap         (__TODO, package, installation: namespaced, configuration) # manage snap packages
conda        (__TODO, package, installation: namespaced, configuration, process-environment) # multi-language package and environment manager
npm          (__TODO, package, installation: project,    configuration) # manage node and JS packages
yarn         (__TODO, package, installation: project,    configuration) # manage node and JS packages
pip          (__TODO, package, installation: project,    configuration) # manage python packages
cargo        (__TODO, package, installation: project,    configuration) # manage rust packages
gem          (__TODO, package, installation: project,    configuration) # manage ruby packages
composer     (__TODO, package, installation: project,    configuration) # manage PHP packages
maven        (__TODO, package, installation: project,    configuration) # manage Java packages
gradle       (__TODO, package, installation: project,    configuration) # manage Java packages
nuget        (__TODO, package, installation: project,    configuration) # manage .NET packages

whereis      (__TODO, search, installation, content) # searches for binary, source, and man pages for a command
which        (__TODO, search, installation, process-environment, content) # show where a command's program is, based on the current $PATH

# Docker container image and instance manager
docker/host/create       (__TODO, create, host)
docker/host/delete       (__TODO, delete, host)
docker/host/show         (__TODO, show,   host, metadata, content)
docker/host-image/create (__TODO, create, host-image, file)
docker/host-image/delete (__TODO, delete, host-image, file)
docker/host-image/show   (__TODO, show,   host-image, file, metadata, content)

# Commands
#   (/data/command)
# --------------------------------------------------

whatis     (__TODO, show,   command, metadata) # show a one-line summary of command
type       (__TODO, show,   command, metadata) # show how a command would be interpreted in the current environment
#"""
`type X` can give output of:
- X is a shell keyword
- X is a shell builtin
- X is aliased to `Y'
- X is a function
- X is hashed (/path/to/X)
- X is /path/to/X
- -bash: type: X: not found
"""
man        (__TODO, show,   command, metadata) # show usage manual for a given command
alias/list (__TODO, show,   command          ) # show command aliases
alias/set  (__TODO, create, command          ) # create a command alias
function   (__TODO, create, command          ) # create a shell function
unalias    (__TODO, delete, command          ) # remove a command alias

# Processes
#   (/process)
# ----------------------------------------------------------------------------------------------------

# Kernel
#   (/process/kernel)
# --------------------

uname       (__TODO, show,         kernel/artifact) # show system information
arch        (__TODO, show,         kernel/artifact) # equivalent to `uname -m`
lsb_release (__TODO, show,         kernel/artifact) # release info for 'standard linux base' (LSB)
modprobe    (__TODO, add, remove,  kernel/module  ) # add or remove (`-r`) modules from the linux kernel
lsmod       (__TODO, show,         kernel/module  ) # list active modules in the running linux kernel
insmod      (__TODO, add,          kernel/module  ) # insert a module into the running linux kernel
rmmod       (__TODO, remove,       kernel/module  ) # remove a module from the running linux kernel
sysctl      (__TODO, show, modify, kernel/param   ) # show and modify linux kernel parameters while the kernel is running
dmesg       (__TODO, show,         kernel/log     ) # show the contents of the kernel message buffer

# Boot and Services
#   (/process/kernel, /process/service)
# --------------------

service    (__OLD,  show, modify, kernel, service, service/config) # manage the system and services (don't use on systemd systems)
systemctl  (__TODO, show, modify, kernel, service, service/config) # manage the system and services (see: `systemctl --help`)
journalctl (__TODO, show, modify, kernel/log, service/log        ) # manage the systemd journal
uptime     (__TODO, show,         kernel                         ) # show how long the system has been running
shutdown   (__TODO, stop,         kernel                         ) # shut down the system; alias for `systemctl shutdown`
halt       (__TODO, stop,         kernel                         ) # halt the system; alias for `systemctl halt`
poweroff   (__TODO, stop,         kernel                         ) # power off the system; alias for `systemctl poweroff`
reboot     (__TODO, restart,      kernel                         ) # reboot the system; alias for `systemctl reboot`

# Process Environment
#   (/process/environment)
# --------------------------------------------------

tty        (__TODO, show, process/environment, terminal       ) # return terminal name, eg. '/dev/tty4' from WSL
stty/show  (__TODO, show, process/environment, terminal       ) # get terminal options
umask/show (__TODO, show, process/environment, identity/policy) # show the file permissions mask (ie. excluded perms) for creating files

@tool (command: env, description: """Print environment variables.""")
@command(
  command: """env"""
)
@query(
  parse: """
    [
      .[0].stdout
      | split("\n")[]
      | capture("^(?<name>[^=]*)=(?<value>.*)$")
      | {
        "process.env.var.id":    (.name),
        "process.env.var.value": (.value)
      }
    ]
  """
)
@subjects (process/env/var: process.env.var.id)
@primary-subject (process/env/var)
env/show   (__TODO, show, process/environment, var            ) # set the file permissions mask (ie. excluded perms) for creating files

@tool (command: pwd, description: """Print working directory.""")
@command (command: """pwd""")
@query (parse: """[{ "dir.id": .[0].stdout }]""")
@subjects (dir: dir.id)
@primary-subject (dir)
pwd        (__TODO, show, process/environment, dir            ) # print working directory

stty/set   (__TODO, set,  process/environment, terminal       ) # set terminal options
tput       (__TODO, set,  process/environment, terminal       ) # set terminal options (see `tput`)
tset       (__TODO, set,  process/environment, terminal       ) # set terminal options (see `tput`)
reset      (__TODO, set,  process/environment, terminal       ) # reset terminal options (see `tput`)
umask/set  (__TODO, set,  process/environment, identity/policy) # set the file permissions mask (ie. excluded perms) for creating files
export     (__TODO, set,  process/environment, var            ) # make environment variable available to programs [sh and dirivatives]
setenv     (__TODO, set,  process/environment, var            ) # csh-style equivalent of the bash-style `export` [csh and dirivatives]
# Shell options?? (eg. pipefail, fail on error, etc.)

#"""
TODO:
- Consider/design:
  - How args/forwarded-data/slots/config/external-state should be handled by commands
    > Note: these correspond to the below subjects for *this* /process/module:
      - config         = /data/process/configuration
      - slots          = /process/environment
      - args           = /process/parameter
      - forwarded-data = /channel/process
      - external-state = various (any subject(s))

    > Args shouldn't need to be accessed. Forwarded data, slots, config, and external
      state should provide sufficient information to run a query or action.

    > Forwarded data should be requested using a special 'dynamic' expansion (which
      is like a normal expansion, but has no module, method, or args, and
      automatically makes the command non-cacheable):
        {{ .() : .parse.expr }}

    > Slots, config, and external state should be requested using a normal expansion:
        {{ context.get_slot(name/of/slot) : .parse.expr }}
        {{ manifest.get_item(name/of/item) : .parse.expr }}
        {{ show.run_refs(name/of/query) : .parse.expr }}

    > The purpose and precedence of the above inputs are determined by each command,
      but commands should follow these guidelines:
      - If forwarded data is given, it should be interpreted as entities to operate
        on instead of data in any applicable slot (eg. for operations on a directory,
        forwarded entities should be interpreted as being of the 'directory' subject,
        and should be used instead of the 'directory/current' slot)
      - Slots should be used for contextual information that wasn't forwarded, or
        that varies along a different axis to forwarded data (if it's not possible to
        index forwarded data by a composite key that would allow multi-axis variation)
      - Config should be used for contextual information that doesn't vary.
      - External state should be interpreted for how to execute the command, but not
        for the intent of the command.

  - How this relates to subjects, and how modifying subjects works with the command
    words
    - subjects contain multiple pieces of data for which there are different
      queries/actions
    - this is effectively the problem of un-merging queries

    > there should be a way of transforming the 'current' complete state into a new
      state, eg. interactive editor or jq, then passing the bits that have changed to
      the relevant `@action`s to apply the changes.
    > this creates a changes-as-data-modification mechanism, which is good for both
      comprehension/simplicity, control/change management, and automation

  - How multiple entities being returned by the same 'getter' might work (eg. env)
    - What about dynamic slots, like 'env', where one query = many slots?
    - Or more importantly, when `env` (the getter) and `export` (the setter) work
      with different multiplicities. In this example, forwarded entities would have to
      be forwarded with expansion to set all slots using `env`, or to set all env vars
      using `export`.

- Implement:
  - @action
  - @context-getter(<subject, ...>)
  - @context-setter(<subject, ...>[, current-shell: true])
    - Where 'current-shell' means that it must be run in the current shell, not as a subprocess
  - @context-validator(<subject, ...>)

- Ideally implement:
  - @context(setter-for: <slot_name>) # For where it can be used, eg. git, but not pwd/cd, env/export, etc.
"""

@tool (
  command: cd
  description: """Change directory."""
)
@command(
  command: """cd {{ context.get(dir/current) : ."dir.id" }}"""
)
#@action(
#)
@subjects(
  dir: dir.id
)
cd         (__TODO, set,  process/environment, dir            ) # change directory

clear (__TODO, delete, channel/content) # clear previous output in the terminal
bg    (__TODO, start,  process) # resume a process in the background of a shell
fg    (__TODO, set,    channel) # put a process into the foreground of a shell (ie. connect channels)

# Channels
#   (/channel)
# ----------------------------------------------------------------------------------------------------

# TODO

# Identity
#   (/identity)
# ----------------------------------------------------------------------------------------------------

# TODO

# Change
#   (/change)
# ----------------------------------------------------------------------------------------------------

@tool (
  command: git
  description: """Manage versions and changes to files, particularly software source code."""
) {
  # tracker/repo (is)
  # delta/diff (version/current:staging, staging:store)
  # version/commit (current)
  # version ref/branch (list(branch,tag), current(branch,tag), latest(tag-by-graph,tag-by-date))

  # General Info
  # --------------------

  @command(
    command: """
      pwd &&
    ! git rev-parse --show-toplevel &&
    ! git status --porcelain=v2 --untracked-files=all
    """
  )
  @query(
    parse: """
      [{
        "dir.id": (.[0].stdout),
        "repo.id": (if .[1].status == 0 then .[1].stdout else null end),

        "repo.isClean": (if .[2].status == 0 then .[2].stdout == "" else null end)
      }]
    """
  )
  @subjects(
    dir: dir.id
    repo: repo.id
  )
  @primary-subject(repo)
  repo/git

  # Deltas
  # --------------------

  # TODO: Handle quoted file names (ie. those with spaces and escape sequences)
  # TODO: Handle merge conflicts
  # TODO: Handle submodules:
  #   (M = changed HEAD; m = normal M for the child; single ? = contains untracked files)
  #   except not in --porcelain mode, where any submodule changes are reported as M
  #   what about `--porcelain=v2`?
  @command(
    command: """
      pwd &&
    ! git rev-parse --show-toplevel &&
    ! git status --porcelain=v2 --untracked-files=all
    """
  )
  @query(
    parse: """
      def summary_of_change_line_type(char): (
          if char == "!" then "ignored"
        elif char == "?" then "untracked"
        elif char == "1" then "modified"
        elif char == "2" then "moved-or-copied"
        elif char == "u" then "conflicted"
        else "unrecognised"
        end
      );
      def summary_of_change_type(char): (
          if char == "." then null
        elif char == "!" then "added(ignored)"
        elif char == "?" then "added(untracked)"
        elif char == "A" then "added"
        elif char == "R" then "moved"
        elif char == "C" then "copied"
        elif char == "M" then "modified"
        elif char == "T" then "modified(file-type-changed)"
        elif char == "D" then "deleted"
        else "unrecognised"
        end
      );

      [
        .[0].stdout,
        (if .[1].status == 0 then .[1].stdout else null end)
      ] as [
        $dirPath,
        $repoPath
      ]
      | (
        if .[2].status == 0 then [
          .[2].stdout
          | split("\n")[]
          | capture("^(?<type>.) (?<remaining>.*)$")
          | [.type, .remaining] as [$type, $remaining]
          | (
            $remaining
            | if $type == "?" or $type == "!" then [{
              "file.id": ($repoPath + "/" + .),
              "delta.id": "staging-store",

              "delta.summary":    (summary_of_change_type($type)),
              "delta.index.type": (null)
            }]
            elif $type == "1" then (
              capture("^(?<index>.)(?<tree>.) ((?<sub_is>.)(?<sub_commit>.)(?<sub_tracked>.)(?<sub_untracked>.)) (?<mode_head>[0-7]{6}) (?<mode_index>[0-7]{6}) (?<mode_tree>[0-7]{6}) (?<object_head>[0-9a-f]{40}) (?<object_index>[0-9a-f]{40}) (?<cur_path>.*)$")
              | if .tree != "." then [{
                  "file.id": ($repoPath + "/" + .cur_path),
                  "delta.id": "staging:store",

                  "delta.summary":        (summary_of_change_type(.tree)),
                  "delta.from.file.mode": (if .mode_index != "000000" then .mode_index else null end),
                  "delta.to.file.mode":   (if .mode_tree != "000000" then .mode_tree else null end),

                  "file.submodule":            (.sub_is == "S"),
                  "delta.submodule.commit":    (if .sub_is == "S" then .sub_commit == "C" else null end),
                  "delta.submodule.tracked":   (if .sub_is == "S" then .sub_tracked == "M" else null end),
                  "delta.submodule.untracked": (if .sub_is == "S" then .sub_untracked == "U" else null end)
                }]
                else [] end
              + if .index != "." then [{
                  "file.id": ($repoPath + "/" + .cur_path),
                  "delta.id": "version/current:staging",

                  "delta.summary":        (summary_of_change_type(.index)),
                  "delta.from.file.mode": (if .mode_head != "000000" then .mode_head else null end),
                  "delta.to.file.mode":   (if .mode_index != "000000" then .mode_index else null end),

                  # TODO: How do we know if the submodule info is relating to the head-to-index or index-to-tree change? (same for type 2)
                  "file.submodule":            (.sub_is == "S"),
                  "delta.submodule.commit":    (if .sub_is == "S" then .sub_commit == "C" else null end),
                  "delta.submodule.tracked":   (if .sub_is == "S" then .sub_tracked == "M" else null end),
                  "delta.submodule.untracked": (if .sub_is == "S" then .sub_untracked == "U" else null end)
                }]
                else [] end
            )
            elif $type == "2" then (
              capture("^(?<index>.)(?<tree>.) ((?<sub_is>.)(?<sub_commit>.)(?<sub_tracked>.)(?<sub_untracked>.)) (?<mode_head>[0-7]{6}) (?<mode_index>[0-7]{6}) (?<mode_tree>[0-7]{6}) (?<object_head>[0-9a-f]{40}) (?<object_index>[0-9a-f]{40}) .(?<similarity>[0-9]{1,3}) (?<cur_path>.*)\\t(?<orig_path>.*)$")
              | [
                  if .tree != "." then [{
                    "file.id": ($repoPath + "/" + .cur_path),
                    "delta.id": "staging:store",

                    "delta.summary":            (summary_of_change_type(.tree)),
                    "delta.similarity.percent": (.similarity | tonumber),
                    "delta.from.path":          ($repoPath + "/" + .orig_path),
                    "delta.from.file.mode":     (if .mode_index != "000000" then .mode_index else null end),
                    "delta.to.path":            ($repoPath + "/" + .cur_path),
                    "delta.to.file.mode":       (if .mode_tree != "000000" then .mode_tree else null end),

                    "file.submodule":            (.sub_is == "S"),
                    "delta.submodule.commit":    (if .sub_is == "S" then .sub_commit == "C" else null end),
                    "delta.submodule.tracked":   (if .sub_is == "S" then .sub_tracked == "M" else null end),
                    "delta.submodule.untracked": (if .sub_is == "S" then .sub_untracked == "U" else null end)
                  }]
                  else [] end
                + if .index != "." then [{
                    "file.id": ($repoPath + "/" + .cur_path),
                    "delta.id": "version/current:staging",

                    "delta.summary":            (summary_of_change_type(.index)),
                    "delta.similarity.percent": (.similarity | tonumber),
                    "delta.from.path":          ($repoPath + "/" + .orig_path),
                    "delta.from.file.mode":     (if .mode_head != "000000" then .mode_head else null end),
                    "delta.to.path":            ($repoPath + "/" + .cur_path),
                    "delta.to.file.mode":       (if .mode_index != "000000" then .mode_index else null end),

                    "file.submodule":            (.sub_is == "S"),
                    "delta.submodule.commit":    (if .sub_is == "S" then .sub_commit == "C" else null end),
                    "delta.submodule.tracked":   (if .sub_is == "S" then .sub_tracked == "M" else null end),
                    "delta.submodule.untracked": (if .sub_is == "S" then .sub_untracked == "U" else null end)
                  }]
                  else [] end
              ]
            )
            elif $type == "u" then (
              capture("^(?<onto>.)(?<applied>.) ((?<sub_is>.)(?<sub_commit>.)(?<sub_tracked>.)(?<sub_untracked>.)) (?<mode_stage1>[0-7]{6}) (?<mode_stage2>[0-7]{6}) (?<mode_stage3>[0-7]{6}) (?<mode_tree>[0-7]{6}) (?<object_stage1>[0-9a-f]{40}) (?<object_stage2>[0-9a-f]{40}) (?<object_stage3>[0-9a-f]{40}) (?<cur_path>.*)$")
              | [{
                "file.id": ($repoPath + "/" + .cur_path)
              }]
            )
            end
            | map(
              . + {
                "delta._recordType": summary_of_change_line_type($type)
              }
            )
          )
        ]
        else [] end
        | flatten(1)
      )
      | map(
        {
          "dir.id": ($dirPath),
          "repo.id": ($repoPath)
        } + .
      )
    """
  )
  @subjects(
    dir: dir.id
    repo: repo.id
    delta: delta.id
    file: file.id
  )
  @primary-subject(file)
  delta/file/git/status

  @command(
    command: """
      pwd &&
    ! git rev-parse --show-toplevel &&
    ! git for-each-ref --format='%(objectname:short)|%(refname:short)|%(upstream:short)|%(upstream:track,nobracket)' refs/heads
    """
  )
  @query(
    parse: """
      [
        .[0].stdout,
        (if .[1].status == 0 then .[1].stdout else null end)
      ] as [
        $dirPath,
        $repoPath
      ]
      | [
        .[2].stdout
        | split("\n")[]
        | split("|")
        | {
          "version.id":            (.[0]),
          "version.ref.id":        (.[1]),
          "version.ref.remote.id": (.[2]),

          "version.ref.ahead.remote":  (
            .[3]
            | sub("^(ahead (?<ahead>[0-9]*))?(, )?(behind (?<behind>[0-9]*))?$";"\(.ahead)")
            | if . != "" and . != "null" then tonumber else 0 end
          ),
          "version.ref.behind.remote": (
            .[3]
            | sub("^(ahead (?<ahead>[0-9]*))?(, )?(behind (?<behind>[0-9]*))?$";"\(.behind)")
            | if . != "" and . != "null" then tonumber else 0 end
          )
        }
      ]
      | map(
        {
          "dir.id": ($dirPath),
          "repo.id": ($repoPath)
        } + .
      )
    """
  )
  @subjects(
    dir: dir.id
    repo: repo.id
    version: version.id
    version/ref: version.ref.id
    delta: delta.id
  )
  @primary-subject(version)
  delta/version/git/branch/remote

  # Versions and Version References
  # --------------------

  # ================================================================================================
  # ISSUE:
  #
  # If you want to know what your current branch is, what your remote is, and what commit each of
  # them is on, you may end up with two commits - one for the local (tracking) branch, and one for
  # the remote branch. How do you show them both?
  # - Rename the fields of the remote branch's entity data?
  # - Show the branch + remote branch as two separate records?
  # - Get information about one set of subject(s) (branches, remote branches), but index by a
  #   different subject (version)?
  # - Setup the manifest so that you have to specify all identifying subjects to get their data
  #   - This would probably also require omitting the ID fields for subjects with a higher
  #     multiplicity (which is hard to detect)
  #
  # The general case is any self-join (A - A), or transitive self-join (A - B - C - A, as in the
  # above example)
  #
  # How does this relate to the delta between the local and remote branches?
  # - Usually, a delta would exclude the version at 'beginning', but maybe it shouldn't?
  # - Is there really any difference between `length > 0` and `length > 1`?
  #   - What about "there is *no* difference between A and B"? Shouldn't that yield no results?
  # - Could you tell it to omit the entries in the middle, or is that the *whole point* of a delta -
  # the bit between the two
  # ================================================================================================

  @command(
    command: """
      pwd &&
    ! git rev-parse --show-toplevel &&
    ! git for-each-ref --format='%(objectname:short)|%(refname:short)|%(objectname)|%(authorname)|%(authoremail:trim)|%(authordate:iso-local)|%(committername)|%(committeremail:trim)|%(committerdate:iso-local)' refs/remotes &&
    ! git for-each-ref --format='%(contents:subject)==========' refs/remotes &&
    ! git for-each-ref --format='%(contents:body)==========' refs/remotes &&
    ! git for-each-ref --format='%(trailers:only)==========' refs/remotes &&
    ! git for-each-ref --format='%(contents:signature)==========' refs/remotes
    """
  )
  @query(
    parse: """
      [
        .[0].stdout,
        (if .[1].status == 0 then .[1].stdout else null end)
      ] as [
        $dirPath,
        $repoPath
      ]
      | [
        [
          (.[2].stdout | split("\n")),
          [.[3].stdout | split("==========")[:-1][] | gsub("^\\s+|\\s+$";"")],
          [.[4].stdout | split("==========")[:-1][] | gsub("^\\s+|\\s+$";"")],
          [.[5].stdout | split("==========")[:-1][] | gsub("^\\s+|\\s+$";"")],
          [.[6].stdout | split("==========")[:-1][] | gsub("^\\s+|\\s+$";"")]
        ]
        | transpose[] as [$coreInfo, $subject, $body, $trailers, $signature]
        | $coreInfo
        | split("|")
        | {
          "version.id":            (.[0]),
          "version.ref.id":        (.[1]),

          "version.id.full":       (.[2]),
          "version.author.name":   (.[3]),
          "version.author.email":  (.[4]),
          "version.authored.date": (.[5]),
          "version.creator.name":  (.[6]),
          "version.creator.email": (.[7]),
          "version.created.date":  (.[8]),
          "version.summary":       ($subject),
          "version.description":   (if $body != "" then $body else null end),
          "version.footers":       ($trailers | split("\n")),
          "version.signature":     (if $signature != "" then $signature else null end)
        }
      ]
      | map(
        {
          "dir.id": ($dirPath),
          "repo.id": ($repoPath)
        } + .
      )
    """
  )
  @subjects(
    dir: dir.id
    repo: repo.id
    version: version.id
    version/ref: version.ref.id
  )
  @primary-subject(version/ref)
  version/ref/git/branch/remote

  @command(
    command: """
      pwd &&
    ! git rev-parse --show-toplevel &&
    ! git for-each-ref --format='%(objectname:short)|%(refname:short)|%(upstream:short)|%(HEAD)|%(objectname)|%(authorname)|%(authoremail:trim)|%(authordate:iso-local)|%(committername)|%(committeremail:trim)|%(committerdate:iso-local)' refs/heads &&
    ! git for-each-ref --format='%(contents:subject)==========' refs/heads &&
    ! git for-each-ref --format='%(contents:body)==========' refs/heads &&
    ! git for-each-ref --format='%(trailers:only)==========' refs/heads &&
    ! git for-each-ref --format='%(contents:signature)==========' refs/heads
    """
  )
  @query(
    parse: """
      [
        .[0].stdout,
        (if .[1].status == 0 then .[1].stdout else null end)
      ] as [
        $dirPath,
        $repoPath
      ]
      | [
        [
          (.[2].stdout | split("\n")),
          [.[3].stdout | split("==========")[:-1][] | gsub("^\\s+|\\s+$";"")],
          [.[4].stdout | split("==========")[:-1][] | gsub("^\\s+|\\s+$";"")],
          [.[5].stdout | split("==========")[:-1][] | gsub("^\\s+|\\s+$";"")],
          [.[6].stdout | split("==========")[:-1][] | gsub("^\\s+|\\s+$";"")]
        ]
        | transpose[] as [$coreInfo, $subject, $body, $trailers, $signature]
        | $coreInfo
        | split("|")
        | {
          "version.id":            (.[0]),
          "version.ref.id":        (.[1]),
          "version.ref.remote.id": (if .[2] != "" then .[2] else null end),

          # Even if .[3] == "+", then it is still not in this dir (dir.id) or repo (repo.id)
          "version.ref.isCurrent": (.[3] == "*"),

          "version.id.full":       (.[4]),
          "version.author.name":   (.[5]),
          "version.author.email":  (.[6]),
          "version.authored.date": (.[7]),
          "version.creator.name":  (.[8]),
          "version.creator.email": (.[9]),
          "version.created.date":  (.[10]),
          "version.summary":       ($subject),
          "version.description":   (if $body != "" then $body else null end),
          "version.footers":       ($trailers | split("\n")),
          "version.signature":     (if $signature != "" then $signature else null end)
        }
      ]
      | map(
        {
          "dir.id": ($dirPath),
          "repo.id": ($repoPath)
        } + .
      )
    """
  )
  @subjects(
    dir: dir.id
    repo: repo.id
    version: version.id
    version/ref: version.ref.id
  )
  @primary-subject(version/ref)
  version/ref/git/branch

  @command(
    command: """
      pwd &&
    ! git rev-parse --show-toplevel &&
    ! git for-each-ref --format='%(objectname:short)|%(refname:short)|%(HEAD)|%(objecttype)|%(objectname:short)|%(objectname)|%(*objectname:short)|%(*objectname)|%(taggername)|%(taggeremail:trim)|%(taggerdate:iso-local)|%(*authorname)|%(*authoremail:trim)|%(*authordate:iso-local)|%(*committername)|%(*committeremail:trim)|%(*committerdate:iso-local)|%(authorname)|%(authoremail:trim)|%(authordate:iso-local)|%(committername)|%(committeremail:trim)|%(committerdate:iso-local)' refs/tags &&
    ! git for-each-ref --format='%(contents:subject)==========' refs/tags &&
    ! git for-each-ref --format='%(contents:body)==========' refs/tags &&
    ! git for-each-ref --format='%(trailers:only)==========' refs/tags &&
    ! git for-each-ref --format='%(contents:signature)==========' refs/tags &&
    ! git for-each-ref --format='%(*contents:subject)==========' refs/tags &&
    ! git for-each-ref --format='%(*contents:body)==========' refs/tags &&
    ! git for-each-ref --format='%(*trailers:only)==========' refs/tags &&
    ! git for-each-ref --format='%(*contents:signature)==========' refs/tags
    """
  )
  @query(
    parse: """
      [
        .[0].stdout,
        (if .[1].status == 0 then .[1].stdout else null end)
      ] as [
        $dirPath,
        $repoPath
      ]
      | [
        [
          (.[2].stdout | split("\n")),
          [.[3].stdout | split("==========")[:-1][] | gsub("^\\s+|\\s+$";"")],
          [.[4].stdout | split("==========")[:-1][] | gsub("^\\s+|\\s+$";"")],
          [.[5].stdout | split("==========")[:-1][] | gsub("^\\s+|\\s+$";"")],
          [.[6].stdout | split("==========")[:-1][] | gsub("^\\s+|\\s+$";"")],
          [.[7].stdout | split("==========")[:-1][] | gsub("^\\s+|\\s+$";"")],
          [.[8].stdout | split("==========")[:-1][] | gsub("^\\s+|\\s+$";"")],
          [.[9].stdout | split("==========")[:-1][] | gsub("^\\s+|\\s+$";"")],
          [.[10].stdout | split("==========")[:-1][] | gsub("^\\s+|\\s+$";"")]
        ]
        | transpose[] as [
          $coreInfo,
          $subject, $body, $trailers, $signature,
          $peeledSubject, $peeledBody, $peeledTrailers, $peeledSignature
        ]
        | $coreInfo
        | split("|")
        | {
          "version.id":            (.[0]),
          "version.ref.id":        (.[1]),

          # Even if .[2] == "+", then it is still not in this dir (dir.id) or repo (repo.id)
          "version.ref.isCurrent": (.[2] == "*")
        } + (
          if .[3] == "tag" then {
            "version.ref.obj.id":        (.[4]),
            "version.ref.obj.id.full":   (.[5]),
            "version.ref.author.name":   (.[8]),
            "version.ref.author.email":  (.[9]),
            "version.ref.authored.date": (.[10]),
            "version.ref.summary":       ($subject),
            "version.ref.description":   (if $body != "" then $body else null end),
            "version.ref.footers":       ($trailers | split("\n")),
            "version.ref.signature":     (if $signature != "" then $signature else null end),

            "version.id":                (.[6]),
            "version.id.full":           (.[7]),
            "version.author.name":       (.[11]),
            "version.author.email":      (.[12]),
            "version.authored.date":     (.[13]),
            "version.creator.name":      (.[14]),
            "version.creator.email":     (.[15]),
            "version.created.date":      (.[16]),
            "version.summary":           ($peeledSubject),
            "version.description":       (if $peeledBody != "" then $peeledBody else null end),
            "version.footers":           ($peeledTrailers | split("\n")),
            "version.signature":         (if $peeledSignature != "" then $peeledSignature else null end)
          } else {
            "version.id":            (.[4]),
            "version.id.full":       (.[5]),
            "version.author.name":   (.[17]),
            "version.author.email":  (.[18]),
            "version.authored.date": (.[19]),
            "version.creator.name":  (.[20]),
            "version.creator.email": (.[21]),
            "version.created.date":  (.[22]),
            "version.summary":       ($subject),
            "version.description":   (if $body != "" then $body else null end),
            "version.footers":       ($trailers | split("\n")),
            "version.signature":     (if $signature != "" then $signature else null end)
          } end
        )
      ]
      | map(
        {
          "dir.id": ($dirPath),
          "repo.id": ($repoPath)
        } + .
      )
    """
  )
  @subjects(
    dir: dir.id
    repo: repo.id
    version: version.id
    version/ref: version.ref.id
  )
  @primary-subject(version/ref)
  version/ref/git/tag

  @command(
    command: """
      pwd &&
    ! git rev-parse --show-toplevel &&
    ! git reflog stash --pretty='%h|%gd'
    """
  )
  @query(
    parse: """
      [
        .[0].stdout,
        (if .[1].status == 0 then .[1].stdout else null end)
      ] as [
        $dirPath,
        $repoPath
      ]
      | [
        .[2].stdout
        | split("\n")[]
        | split("|")
        | {
          "version.id":     (.[0]),
          "version.ref.id": (.[1])
        }
      ]
      | map(
        {
          "dir.id": ($dirPath),
          "repo.id": ($repoPath)
        } + .
      )
    """
  )
  @subjects(
    dir: dir.id
    repo: repo.id
    version: version.id
    version/ref: version.ref.id
  )
  @primary-subject(version/ref)
  version/ref/git/stash

  # Specific Entities
  # --------------------

  @command(
    command: """
      pwd &&
    ! git rev-parse --show-toplevel &&
    ! git rev-parse --short HEAD &&
    ! git rev-parse HEAD
    """
  )
  @query(
    parse: """
      [{
        "dir.id":     (.[0].stdout),
        "repo.id":    (if .[1].status == 0 then .[1].stdout else null end),
        "version.id": (if .[2].status == 0 then .[2].stdout else null end),

        "version.id.full": (if .[3].status == 0 then .[3].stdout else null end)
      }]
    """
  )
  @subjects(
    dir: dir.id
    repo: repo.id
    version: version.id
  )
  @primary-subject(version)
  version/current/git

  @command(
    command: """
      pwd &&
    ! git rev-parse --show-toplevel &&
    ! git symbolic-ref --short -q HEAD &&
    - show.run_refs(version/ref/git/branch) :: $
    """
  )
  @query(
    parse: """
      [
        {
          "dir.id":         (.[0].stdout),
          "repo.id":        (if .[1].status == 0 then .[1].stdout else null end),
          "version.ref.id": (if .[2].status == 0 and .[2].stdout != "" then .[2].stdout else null end)
        } + (
          [.[3].stdout, .[2].stdout] as [$branches, $curBranch]
          | if .[2].status == 0 and $curBranch != "" then $branches[$curBranch] else {} end
        )
      ]
    """
  )
  @subjects(
    dir: dir.id
    repo: repo.id
    version/ref: version.ref.id
  )
  @primary-subject(version/ref)
  version/ref/current/git/branch

  @command(
    command: """
      pwd &&
    ! git rev-parse --show-toplevel &&
    ! git describe --tags --exact-match
    """
  )
  @query(
    parse: """
      [{
        "dir.id":         (.[0].stdout),
        "repo.id":        (if .[1].status == 0 then .[1].stdout else null end),
        "version.ref.id": (if .[2].status == 0 and .[2].stdout != "" then .[2].stdout else null end)
      }]
    """
  )
  @subjects(
    dir: dir.id
    repo: repo.id
    version/ref: version.ref.id
  )
  @primary-subject(version/ref)
  version/ref/current/git/tag

  @command(
    command: """
      pwd &&
    ! git rev-parse --show-toplevel &&
    ! git rev-list --tags --max-count=1 --pretty=format:'%h' &&
    ! git rev-list --tags --max-count=1 --pretty=format:'%D' &&
    ! git for-each-ref refs/tags --sort=-creatordate --format='%(objectname:short)' --count=1 &&
    ! git for-each-ref refs/tags --sort=-creatordate --format='%(refname:short)' --count=1
    """
  )
  @query(
    parse: """
      (
        if .[3].status == 0 and .[3].stdout != "" then [
          [.[0], .[1], .[2], .[3]] as [$_0, $_1, $_2, $_3]
          | .[3].stdout
          | split("\n")[1]
          | split(", ")[]
          | select(startswith("tag: "))
          | sub("^tag: ";"")
          | {
            "dir.id":         ($_0.stdout),
            "repo.id":        (if $_1.status == 0 then $_1.stdout else null end),
            "version.id":     (if $_2.status == 0 and $_2.stdout != "" then $_2.stdout | split("\n")[1] else null end),
            "version.ref.id": (.),

            "version.ref.isOrderedLast": (true)
          }
        ] else [] end
      ) + (
        if .[5].status == 0 and .[5].stdout != "" then [
          {
            "dir.id":         (.[0].stdout),
            "repo.id":        (if .[1].status == 0 then .[1].stdout else null end),
            "version.id":     (if .[4].status == 0 and .[4].stdout != "" then .[4].stdout else null end),
            "version.ref.id": (.[5].stdout),

            "version.ref.isCreatedLast": (true)
          }
        ] else [] end
      )
    """
  )
  @subjects(
    dir: dir.id
    repo: repo.id
    version/ref: version.ref.id
  )
  @primary-subject(version/ref)
  version/ref/latest/git/tag

  #"""
    TODO
    --------------------

    - See: https://git-scm.com/docs/giteveryday

    # Write/Modify Commands (workflow)
    # ----------

    # Might require `--no-optional-locks`, ie. don't write things you don't need to

    git clone $remote_url $local_path
    git fetch --tags -p -f

    git branch $branch $source_ref
    git branch -m # rename branch
    git branch --unset-upstream
    git branch -d/-D # delete / force-delete branch

    # Stash changes
    git stash --include-untracked # normal stash + unstaged, non-ignored files
    git stash --all # stash EVERYTHING
    git stash pop --index # Re-stage changes that were staged before stash

    # Change branch
    git checkout
    + git submodule update # stash? "would be overridden by checkout"?

    git rebase origin/$branch
    git rebase -i $default_branch
    git rebase --abort

    git push --force-with-lease
    git push origin :$branch

    # TODO:
    # - update all (active) branches, not just the current branch
    # - cache entries should include the data they were created, so:
    #   - they can be invalidated by time
    #   - they can be set incrementally (ie. extended)
    # - keep history of branches?
    #   - eg. after deletion, which commit was the branch at? for destroying infra
    # - categorise branches and tags
    # - categorise MRs/PRs on the remote(s), eg. origin

    # Requires Parameters
    # ----------

    # git info format
    #project | default_branch | D^< >D< >C< >C^ | num_branches | orphans

    # Branch exists?
    git rev-parse --verify $branch

    # Get tracking branch
    branch_ref=refs/heads/$branch
    git for-each-ref --format='%(upstream:short)' $branch_ref

    # How many commits from one branch to another
    git rev-list --count $from_branch..$to_branch

    # Conventional stuff, like:
    git log --format='%s' $branch_ref | grep "^[^(]*\($type\): "

    # Remote tracking branch exists
    git ls-remote --heads origin $branch_ref

    # get ref of commit ID
    git describe --tags $commit_id

    # Get author date of commit at $ref
    git log --date=format:%Y-%m-%d --pretty=format:%ad $ref

    # Get formatted log of commit
    git log -1 format=$format $ref

    # Format every ref (eg. for getting branches with some patterns filtered out)
    git for-each-ref --format=$format refs/heads
  """
}

# Categories
# ----------------------------------------------------------------------------------------------------

artifact   [package | host-image]
deployment [installation | instance]

/category/hardware     [command & [/hardware]]
/category/data/general [command & [/data/filesystem | /data/file | /data/dir]]
/category/data/process [command & [
    /data/source
  | /data/artifact
  | /data/deployment
  | /data/configuration
]]
/category/data/processor [command & [
    /data/text
  | /data/number
  | /data/time
  | /data/command
  | /data/path
  | /data/email
  | /data/word
]]
# /data/process-state??

# NOT YET INTEGRATED
#/category/process             [command & []]
#/category/process-env         [command & []]
#/category/application         [command & []]
#/category/channel             [command & []]
#/category/identity-and-access [command & []]
