#"""
System commands operate on the system.

Operations are Creation, Representation, Management, and Destruction. These
operations are broader than CRUD (eg. representation includes display as well as
retreival, and management includes more than just updates).
"""

:__DUPLICATE (description: """Unused because it only contains functionality that another tool has, and may do better""")
:__OLD (description: """Out of date, and should no longer be used""")
:__TODO (description: """Not fully defined in the manifest yet""")

@tags (system) {

# Hardware
# ----------------------------------------------------------------------------------------------------

biosdecode (__TODO, hardware) # description of system's bios/uefi
dmidecode  (__TODO, hardware) # description of system's hardware components

# See:
# - https://dassencio.org/75
@tool (
  command: lspci
  description: """List PCI devices."""
) {
  @query (
    command: """lspci -vvmmnn -D"""
    parse: """
      gsub("^\\s*|\\s*$"; "")
      | split("\n\n")
      | map(
        [
          split("\n")[]
          | capture("^(?<key>[^:]*):\t(?<value>.*)$")
        ]
        | from_entries
        | {
          id:           (.Slot),

          domain:       (.Slot | split(".")[0] | split(":")[0]),
          bus:          (.Slot | split(".")[0] | split(":")[1]),
          device:       (.Slot | split(".")[0] | split(":")[2]),
          function:     (.Slot | split(".")[1]),

          classId:      (.Class | sub(".* \\[(?<id>[0-9a-f]*)\\]"; "\(.id)")),
          className:    (.Class | sub("(?<name>.*) \\[[0-9a-f]*\\]"; "\(.name)")),
          vendorId:     (.Vendor | sub(".* \\[(?<id>[0-9a-f]*)\\]"; "\(.id)")),
          vendorName:   (.Vendor | sub("(?<name>.*) \\[[0-9a-f]*\\]"; "\(.name)")),
          deviceId:     (.Device | sub(".* \\[(?<id>[0-9a-f]*)\\]"; "\(.id)")),
          deviceName:   (.Device | sub("(?<name>.*) \\[[0-9a-f]*\\]"; "\(.name)")),

          physicalSlot: (.PhySlot),
          revision:     (.Rev)
        }
      )
    """
  )
  lspci/main (hardware, pci)

  @query (
    command: """lspci -vv"""
    parse: """
      gsub("^\\s*|\\s*$"; "")
      | split("\n\n")
      | map(
        {
          id: capture("^(?<id>[0-9a-f:\\.]*)").id
        }
        + (
          [
            split("\n")[]
            | capture("^\\t(?<key>[^:]*): (?<value>.*)$")
          ]
          | from_entries
          | {
            control:      .Control,
            status:       .Status,
            latency:      .Latency,
            kernelDriver: ."Kernel driver in use"
          }
        )
      )
    """
  )
  lspci/extras (hardware, pci)
}

# TODO: Finish this off
# See:
# - https://www.google.co.uk/search?q=linux+check+readahead
# - https://www.postgresql.org/message-id/a1ec7d000809111207x3f5aefb9ybc66c556c532084b@mail.gmail.com
# - https://www.google.co.uk/search?q=disk+readahead
# - https://myadventuresincoding.wordpress.com/2020/10/04/cassandra-improving-disk-i-o-by-tuning-readahead/
lsblk (__TODO, hardware)
@tool (
  command: lsblk
  description: """List device, block, partition table, partition, and filesystem information."""
) {  
  # Entity Hierarchy:
  #   Device (opt. Partition Table) > Block (opt. Partition) > Filesystem

  @query (
    command: """lsblk -a -bDz -Jlo MAJ:MIN,TYPE,PATH,RM,HOTPLUG,WWN,SERIAL,REV,MODEL,VENDOR,TRAN,RQ-SIZE,PHY-SEC,LOG-SEC,MIN-IO,OPT-IO,DISC-ALN,DISC-GRAN,DISC-MAX,DISC-ZERO,RAND"""
    parse: """
      fromjson
      | .blockdevices
      | map(
        select(.type == "disk")
        | {
          # Identity and Relationships
          # This uses the same IDs as blocks, because they cannot be
          # differentiated by kernel ID without assuming too much about the
          # kernel implementation (which is presumably why `lsblk` does not
          # differentiate either).
          id:                 (."maj:min"),
          driverId:           (."maj:min" | split(":")[0]),
          driverBlockId:      (."maj:min" | split(":")[1]),

          # General Info (Optional)
            # If uid is null, then probably not a physical device
          uid:                (.wwn),
          serial:             (.serial),
          revision:           (.rev),
          model:              (.model),
          vendor:             (.vendor),

          # General Technical Info
          filePath:           (.path),

          # Hardware Info
          connectionType:     (.tran),
          isRemovable:        ([.rm, .hotplug] | any),
          isEntropySource:    (.rand),

          # Hardware Sizes
          requestQueueSize:   (."rq-size"),
          physicalSectorSize: (."phy-sec"),
          logicalSectorSize:  (."log-sec"),
          minimumIOSize:      (."min-io"),
          optimalIOSize:      (."opt-io"), # sometimes reports 0

          # Trim (ie. active garbage collection; only some devices)
              # TODO: What does this mean ???
          trimAlignment:      (."disc-aln"),
            # bytes; usually the physical sector size, but can be larger
          trimGranularity:    (."disc-gran"),
            # bytes; maximum unmappable bytes for drive
            # see: https://www.jeffgeerling.com/blog/2020/enabling-trim-on-external-ssd-on-raspberry-pi
          trimMaxBytes:       (."disc-max"),
            # reports if device zero-fills on trim; some filesystems require this
          trimDoesZeroFill:   (."disc-zero"),
        }
      )
    """
  )
  lsblk/device (hardware, device)

  @query (
    command: """lsblk -a -bDz -Jlo MAJ:MIN,PTUUID,PTTYPE"""
    parse: """
      fromjson
      | .blockdevices
      | map(
        # Device-to-PartitionTable = 1-to-[0,1]
        # The data is also available on "part"-type blocks, but it is duplicate
        # data - a disk can only have one partition table.
        select(.type == "disk" and .ptuuid != null)
        | {
          # Identity and Relationships
          id:     (."maj:min"),

          # Partition Table
          partitionTable: {
            uid:  (.ptuuid),
            type: (.pttype),
          }
        }
      )
    """
  )
  lsblk/device/partition-table (hardware, device, partition-table)

  @query (
    command: """lsblk -a -bDz -Jlo MAJ:MIN,NAME,KNAME,PATH,TYPE,SIZE,RA,ROTA,STATE,RO,OWNER,GROUP,MODE"""
    parse: """
      fromjson
      | .blockdevices
      | map({
        # Identity and Relationships
        id:                (."maj:min"),
        driverId:          (."maj:min" | split(":")[0]),
        driverBlockId:     (."maj:min" | split(":")[1]),

        # General Info
            # Does a block always have a UUID? (some do - see other queries)
        name:              (.name),  # eg. "nvme1n1"
        kernelName:        (.kname), # eg. "nvme1n1" (sometimes != name)
        type:              (.type),  # eg. "loop", "disk", "part"ition

        # Status (optional - disk only)
        state:             (.state), # eg. "running" (HDD), "live" (SSD)

        # Storage Space
        storageSpaceTotal: (.size),

        # Performance
            # not the total size in bytes - it's measured in blocks, but of what size?
        readAheadSize:     (.ra),
        isRotationalDisk:  (.rota),

        # Permissions
        isReadOnly:        (.ro),
        filePath:          (.path),  # eg. "/dev/nvme1n1"
        fileOwner:         (.owner),
        fileGroup:         (.group),
        filePermissions:   (.mode),
      })
    """
  )
  lsblk/block (hardware, block)

  @query (
    command: """lsblk -a -bDz -Jlo MAJ:MIN,TYPE,PARTUUID,PARTLABEL,PARTTYPE,PARTTYPENAME,PARTFLAGS"""
    parse: """
      fromjson
      | .blockdevices
      | map(
        # Block-to-Partition = subtype (therefore 1-to-[0,1])
        select(.type == "part")
        | {
          # Identity and Relationships
          id:       (."maj:min"),

          partition: {
            uid:    (.partuuid),
            name:   (.partlabel), # ===== FIXME: if it's a subtype, why does it have two names (or types, etc.)?
                # TODO: needed?
            type:   (.parttypename),
            typeId: (.parttype),
              # Eg. "esp", "boot", "msftres", etc; pttype-specific
            flags:  (.partflags),
          },
        }
      )
    """
  )
  lsblk/block/partition (hardware, block, partition)

  @query (
    command: """lsblk -a -bDz -Jlo MAJ:MIN,UUID,LABEL,FSTYPE,FSVER,FSSIZE,FSUSED,FSAVAIL,FSROOTS,MOUNTPOINTS"""
    parse: """
      fromjson
      | .blockdevices
      | map(
        select((.type == "disk" or .type == "part") and .uuid != null)
        | {
          id: (."maj:min" + "/" + .uuid),

          # General
          uid:            (.uuid),
          name:           (.label),
          type:           (.fstype),
          version:        (.fsver),

          # Size (usually - ntfs does not have this for some reason)
          spaceTotal:     (.fssize),
          spaceUsed:      (.fsused),
          spaceAvailable: (.fsavail),

          # Mounts
          # NOTE: The representation of 'none' is changing soon.
          #       See https://github.com/util-linux/util-linux/issues/2871
          # NOTE: They always come in pairs because each 'filesystem' has one.
          #       See https://github.com/util-linux/util-linux/blob/master/libmount/src/fs.c#L1258
          mounts: (
            [
              .fsroots,    # Where on this filesystem is considered the root directory
              .mountpoints # Where in the system filesystem is the root directory of this filesystem attached
            ]
            | transpose
            | map({
              root: .[0],
              mountpoint: .[1]
            })
          ),
        }
      )
    """
  )
  lsblk/filesystem (hardware, filesystem)
}
blkid (__DUPLICATE, hardware, block) # Show block device information. Unnecessary - use `lsblk` instead.

lsusb (__TODO, hardware) # List USB devices

# Storage: Filesystems, Directories, and Files
# ----------------------------------------------------------------------------------------------------

# Filesystem
# --------------------

# Create and Delete
mkfs         (__TODO, create, filesystem) # create a filesystem of the given type
cryptsetup   (__TODO, create, filesystem) # create and set up a LUKS encrypted filesystem

# Read
mount/show   (__TODO, show,   filesystem) # show info about mounts of a filesystem
df           (__TODO, show,   filesystem) # show filesystem storage space, mounts, etc. info (stands for 'disk filesystem')
fstyp        (__TODO, show,   filesystem) # show filesystem types [only available on some systems; can usually use `mount` for this]
fsck         (__TODO, verify, filesystem) # check filesystem for errors and other issues, and attempt to fix them
# FIXME: Some other commands from `hardware` do this too, eg. lsblk

# Write
growfs       (__TODO, modify, filesystem) # enlarge a ufs filesystem [bsd only]
tune2fs      (__TODO, modify, filesystem) # adjust filesystem parameters [ext2/3/4]
sync         (__TODO, sync,   filesystem) # flush filesystem buffers
mount/attach (__TODO, attach, filesystem) # mount or unmount a filesystem
umount       (__TODO, attach, filesystem) # unmount a filesystem

# File and Directory
# --------------------

# Create and Delete
mkdir        (__TODO, create,                 dir) # create dir
touch/create (__TODO, create,           file     ) # create file (and set timestamps)
ln           (__TODO, create, symlink,  file     ) # create symbolic link file
mkfifo       (__TODO, create, pipe,     file     ) # create named pipe file
mknod        (__TODO, create, device,   file     ) # create char/block device files & other special files
ar           (__TODO, create, archive,  file     ) # create an archive
tar          (__TODO, create, archive,  file     ) # create a tar archive
zip          (__TODO, create, archive,  file     ) # package and compress files/dirs into zip (`.zip`) file
unzip        (__TODO, create,           file, dir) # decompress and unpackage zip file
gzip         (__TODO, create, archive,  file     ) # package and compress files/dirs into gzip (`.gz`) file
gunzip       (__TODO, create,           file, dir) # decompress and unpackage gzip file
compress     (__TODO, create, archive,  file     ) # compress (gzip?) file or all files in dir recursively (`-r`), adding `.Z` extension
uncompress   (__TODO, create,           file, dir) # uncompress (gzip?) file or all files in dir recursively (`-r`), removing `.Z` extension
rm           (__TODO, delete,           file, dir) # delete file/dir
unlink       (__TODO, delete,           file, dir) # delete file/dir (lower-level version of `rm`) [use `rm` instead]
rmdir        (__TODO, delete,                 dir) # delete an empty dir [use `rm` instead]
shred        (__TODO, delete,           file, dir, secure) # overwrite a file several times to hide its contents

# Read
du           (__TODO, show,             file,      metadata         ) # show file/dir storage space info (stands for 'disk usage')
ls           (__TODO, show,             file, dir, metadata         ) # show file files in a directory and show file attributes
file         (__TODO, show,             file, dir, metadata         ) # show file/dir type
stat         (__TODO, show,             file, dir, metadata         ) # show inode metadata
readlink     (__TODO, show,    symlink, file,                content) # show symbolic link content
cat          (__TODO, show,    text,    file,                content) # concatenate files and output results
tac          (__TODO, show,    text,    file,                content) # cat, then reverses the order of the output [GNU only]
zcat         (__TODO, show,    archive, file,                content) # show contents of gzip compressed file
xzcat        (__TODO, show,    archive, file,                content) # show contents of xz compressed file
bzcat        (__TODO, show,    archive, file,                content) # show contents of bzip compressed file
zzcat        (__TODO, show,    archive, file,                content) # show contents of zip compressed file
less         (__TODO, show,    text,    file,                content, is: app) # view one or more files
more         (__TODO, show,    text,    file,                content, is: app) # view one or more files
find         (__TODO, search,           file, dir, metadata         ) # search for files by name/pattern, attributes, etc. or list files with filters
ff           (__TODO, search,           file, dir, metadata         ) # search for files by name (and others? anywhere on the system; stands for 'find files')
grep         (__TODO, search,           file,                content) # search for files containing patterns
egrep        (__TODO, search,           file,                content) # search for files containing patterns
diff         (__TODO, compare,          file, dir,           content) # compare files
cmp          (__TODO, compare,          file,                content) # compare files byte-by-byte
comm         (__TODO, compare, text,    file,                content) # compare sorted files for common/uncommon lines

# Write
touch/set    (__TODO, set,              file,      metadata         ) # create file (and set timestamps)
chown        (__TODO, set,              file, dir, metadata         ) # set ownership of file/dir
chgrp        (__TODO, set,              file, dir, metadata         ) # set group ownership [use `chown` instead]
chmod        (__TODO, set,              file, dir, metadata         ) # set mode (ie. permissions) of file/dir
truncate     (__TODO, set,              file,                content) # shrink or extend size of file (`-s [+-<>/%]INT([K,M,G,T,P,E,Z,Y][B])`)
patch        (__TODO, set,              file,                content) # apply a diff to a file
tee          (__TODO, set,              file,                content) # both write (overwrite or append) input to a file, and output the input unchanged
ed           (__TODO, show, set, text,  file,                content, is: app) # edit one or more files
nano         (__TODO, show, set, text,  file,                content, is: app) # edit one or more files
vi           (__TODO, show, set, text,  file,                content, is: app) # edit one or more files
vim          (__TODO, show, set, text,  file,                content, is: app) # edit one or more files
emacs        (__TODO, show, set, text,  file,                content, is: app) # edit one or more files
cp           (__TODO, copy,             file, dir, metadata, content) # copy a file/dir
dd           (__TODO, copy,             file,      metadata, content, over: process/channel) # copy (and convert) a file (or dir??) (as a stream) to any other file, including a device file
ftp          (__TODO, copy,             file, dir, metadata, content, over: host/channel) # transfer files/dirs to/from another host using FTP
sftp         (__TODO, copy,             file, dir, metadata, content, over: host/channel) # transfer files/dirs to/from another host using SFTP (FTP + SSL/TLS)
rcp          (__TODO, copy,             file, dir, metadata, content, over: host/channel) # transfer files/dirs to/from another host using RSH (stands for 'remote copy')
scp          (__TODO, copy,             file, dir, metadata, content, over: host/channel) # transfer files/dirs to/from another host using SSH (stands for 'secure copy')
# FIXME: This can copy more than just files - it can copy any HTTP resource
wget         (__TODO, copy,             file, dir, metadata, content, over: host/channel) # fetch a file from another host using HTTP or HTTPS
# FIXME: This can more than just copy files - it can send any HTTP request
curl         (__TODO, copy,             file, dir, metadata, content, over: host/channel) # fetch a file from another host using HTTP or HTTPS
mv           (__TODO, move,             file, dir, metadata, content) # move a file/dir
rsync/local  (__TODO, sync,             file, dir, metadata, content) # sync files/dirs
rsync/remote (__TODO, sync,             file, dir, metadata, content, over: host/channel) # sync files/dirs over the network

# Projects: Sources, Artifacts, Deployments, and Configurations
# ----------------------------------------------------------------------------------------------------

# FIXME: Every package manager has the following variations:
#create, installation
#delete, installation
#show, package, store, metadata, content
#show, package, metadata
#show, installation, metadata
dpkg         (__TODO, package, installation: global,     configuration) # manage deb packages
apt-get      (__TODO, package, installation: global,     configuration) # manage deb packages
apt-cache    (__TODO, package, installation: global,     configuration) # manage the APT cache
apt          (__TODO, package, installation: global,     configuration) # manage deb packages and the APT chache
aptitute     (__TODO, package, installation: global,     configuration) # manage deb packages
yum          (__TODO, package, installation: global,     configuration) # manage rpm packages
rpm          (__TODO, package, installation: global,     configuration) # manage rpm packages
pacman       (__TODO, package, installation: global,     configuration) # manage tar packages
brew         (__TODO, package, installation: global,     configuration) # manage build scripts ('formulae') and binary packages ('bottles')
flatpak      (__TODO, package, installation: namespaced, configuration) # manage flatpack packages
snap         (__TODO, package, installation: namespaced, configuration) # manage snap packages
conda        (__TODO, package, installation: namespaced, configuration, process-environment) # multi-language package and environment manager
npm          (__TODO, package, installation: project,    configuration) # node and JS package manager
yarn         (__TODO, package, installation: project,    configuration) # node and JS package manager
pip          (__TODO, package, installation: project,    configuration) # python package manager
cargo        (__TODO, package, installation: project,    configuration) # rust package manager
gem          (__TODO, package, installation: project,    configuration) # ruby package manager
composer     (__TODO, package, installation: project,    configuration) # PHP package manager
maven        (__TODO, package, installation: project,    configuration) # Java package manager
gradle       (__TODO, package, installation: project,    configuration) # Java package manager
nuget        (__TODO, package, installation: project,    configuration) # .NET package manager

whereis      (__TODO, search, installation, content) # searches for binary, source, and man pages for a command
which        (__TODO, search, installation, process-environment, content) # show where a command's program is, based on the current $PATH

# Docker container image and instance manager
docker/host/create       (__TODO, create, host)
docker/host/delete       (__TODO, delete, host)
docker/host/show         (__TODO, show,   host, metadata, content)
docker/host-image/create (__TODO, create, host-image, file)
docker/host-image/delete (__TODO, delete, host-image, file)
docker/host-image/show   (__TODO, show,   host-image, file, metadata, content)

@tool (
  command: git
  description: """Manage versions and changes to files, particularly software source code."""
) {
  # tracker/repo (is)
  # delta/diff (version/current:staging, staging:store)
  # version/commit (current)
  # version ref/branch (list(branch,tag), current(branch,tag), latest(tag-by-graph,tag-by-date))

  # General Info
  # --------------------

  @query(
    command: """
      pwd &&
    ! git rev-parse --show-toplevel &&
    ! git status --porcelain=v2 --untracked-files=all
    """
    parse: """
      [{
        "dir.id": (.[0].stdout),
        "repo.id": (if .[1].status == 0 then .[1].stdout else null end),

        "repo.isClean": (if .[2].status == 0 then .[2].stdout == "" else null end)
      }]
    """
  )
  @subjects(
    dir: dir.id
    repo: repo.id
  )
  @primary-subject(repo)
  repo/git

  # Delta - Store to Version
  # --------------------

  # TODO: Handle quoted file names (ie. those with spaces and escape sequences)
  # TODO: Handle merge conflicts
  # TODO: Handle submodules:
  #   (M = changed HEAD; m = normal M for the child; single ? = contains untracked files)
  #   except not in --porcelain mode, where any submodule changes are reported as M
  #   what about `--porcelain=v2`?
  @query(
    command: """
      pwd &&
    ! git rev-parse --show-toplevel &&
    ! git status --porcelain=v2 --untracked-files=all
    """
    parse: """
      def summary_of_change_line_type(char): (
          if char == "!" then "ignored"
        elif char == "?" then "untracked"
        elif char == "1" then "modified"
        elif char == "2" then "moved-or-copied"
        elif char == "u" then "conflicted"
        else "unrecognised"
        end
      );
      def summary_of_change_type(char): (
          if char == "." then null
        elif char == "!" then "added(ignored)"
        elif char == "?" then "added(untracked)"
        elif char == "A" then "added"
        elif char == "R" then "moved"
        elif char == "C" then "copied"
        elif char == "M" then "modified"
        elif char == "T" then "modified(file-type-changed)"
        elif char == "D" then "deleted"
        else "unrecognised"
        end
      );

      [
        .[0].stdout,
        (if .[1].status == 0 then .[1].stdout else null end)
      ] as [
        $dirPath,
        $repoPath
      ]
      | (
        if .[2].status == 0 then [
          .[2].stdout
          | split("\n")[]
          | capture("^(?<type>.) (?<remaining>.*)$")
          | [.type, .remaining] as [$type, $remaining]
          | (
            $remaining
            | if $type == "?" or $type == "!" then [{
              "file.id": ($repoPath + "/" + .),
              "delta.id": "staging-store",

              "delta.summary":    (summary_of_change_type($type)),
              "delta.index.type": (null)
            }]
            elif $type == "1" then (
              capture("^(?<index>.)(?<tree>.) ((?<sub_is>.)(?<sub_commit>.)(?<sub_tracked>.)(?<sub_untracked>.)) (?<mode_head>[0-7]{6}) (?<mode_index>[0-7]{6}) (?<mode_tree>[0-7]{6}) (?<object_head>[0-9a-f]{40}) (?<object_index>[0-9a-f]{40}) (?<cur_path>.*)$")
              | if .tree != "." then [{
                  "file.id": ($repoPath + "/" + .cur_path),
                  "delta.id": "staging:store",

                  "delta.summary":        (summary_of_change_type(.tree)),
                  "delta.from.file.mode": (if .mode_index != "000000" then .mode_index else null end),
                  "delta.to.file.mode":   (if .mode_tree != "000000" then .mode_tree else null end),

                  "file.submodule":            (.sub_is == "S"),
                  "delta.submodule.commit":    (if .sub_is == "S" then .sub_commit == "C" else null end),
                  "delta.submodule.tracked":   (if .sub_is == "S" then .sub_tracked == "M" else null end),
                  "delta.submodule.untracked": (if .sub_is == "S" then .sub_untracked == "U" else null end)
                }]
                else [] end
              + if .index != "." then [{
                  "file.id": ($repoPath + "/" + .cur_path),
                  "delta.id": "version/current:staging",

                  "delta.summary":        (summary_of_change_type(.index)),
                  "delta.from.file.mode": (if .mode_head != "000000" then .mode_head else null end),
                  "delta.to.file.mode":   (if .mode_index != "000000" then .mode_index else null end),

                  # TODO: How do we know if the submodule info is relating to the head-to-index or index-to-tree change? (same for type 2)
                  "file.submodule":            (.sub_is == "S"),
                  "delta.submodule.commit":    (if .sub_is == "S" then .sub_commit == "C" else null end),
                  "delta.submodule.tracked":   (if .sub_is == "S" then .sub_tracked == "M" else null end),
                  "delta.submodule.untracked": (if .sub_is == "S" then .sub_untracked == "U" else null end)
                }]
                else [] end
            )
            elif $type == "2" then (
              capture("^(?<index>.)(?<tree>.) ((?<sub_is>.)(?<sub_commit>.)(?<sub_tracked>.)(?<sub_untracked>.)) (?<mode_head>[0-7]{6}) (?<mode_index>[0-7]{6}) (?<mode_tree>[0-7]{6}) (?<object_head>[0-9a-f]{40}) (?<object_index>[0-9a-f]{40}) .(?<similarity>[0-9]{1,3}) (?<cur_path>.*)\\t(?<orig_path>.*)$")
              | [
                  if .tree != "." then [{
                    "file.id": ($repoPath + "/" + .cur_path),
                    "delta.id": "staging:store",

                    "delta.summary":            (summary_of_change_type(.tree)),
                    "delta.similarity.percent": (.similarity | tonumber),
                    "delta.from.path":          ($repoPath + "/" + .orig_path),
                    "delta.from.file.mode":     (if .mode_index != "000000" then .mode_index else null end),
                    "delta.to.path":            ($repoPath + "/" + .cur_path),
                    "delta.to.file.mode":       (if .mode_tree != "000000" then .mode_tree else null end),

                    "file.submodule":            (.sub_is == "S"),
                    "delta.submodule.commit":    (if .sub_is == "S" then .sub_commit == "C" else null end),
                    "delta.submodule.tracked":   (if .sub_is == "S" then .sub_tracked == "M" else null end),
                    "delta.submodule.untracked": (if .sub_is == "S" then .sub_untracked == "U" else null end)
                  }]
                  else [] end
                + if .index != "." then [{
                    "file.id": ($repoPath + "/" + .cur_path),
                    "delta.id": "version/current:staging",

                    "delta.summary":            (summary_of_change_type(.index)),
                    "delta.similarity.percent": (.similarity | tonumber),
                    "delta.from.path":          ($repoPath + "/" + .orig_path),
                    "delta.from.file.mode":     (if .mode_head != "000000" then .mode_head else null end),
                    "delta.to.path":            ($repoPath + "/" + .cur_path),
                    "delta.to.file.mode":       (if .mode_index != "000000" then .mode_index else null end),

                    "file.submodule":            (.sub_is == "S"),
                    "delta.submodule.commit":    (if .sub_is == "S" then .sub_commit == "C" else null end),
                    "delta.submodule.tracked":   (if .sub_is == "S" then .sub_tracked == "M" else null end),
                    "delta.submodule.untracked": (if .sub_is == "S" then .sub_untracked == "U" else null end)
                  }]
                  else [] end
              ]
            )
            elif $type == "u" then (
              capture("^(?<onto>.)(?<applied>.) ((?<sub_is>.)(?<sub_commit>.)(?<sub_tracked>.)(?<sub_untracked>.)) (?<mode_stage1>[0-7]{6}) (?<mode_stage2>[0-7]{6}) (?<mode_stage3>[0-7]{6}) (?<mode_tree>[0-7]{6}) (?<object_stage1>[0-9a-f]{40}) (?<object_stage2>[0-9a-f]{40}) (?<object_stage3>[0-9a-f]{40}) (?<cur_path>.*)$")
              | [{
                "file.id": ($repoPath + "/" + .cur_path)
              }]
            )
            end
            | map(
              . + {
                "delta._recordType": summary_of_change_line_type($type)
              }
            )
          )
        ]
        else [] end
        | flatten(1)
      )
      | map(
        {
          "dir.id": ($dirPath),
          "repo.id": ($repoPath)
        } + .
      )
    """
  )
  @subjects(
    dir: dir.id
    repo: repo.id
    delta: delta.id
    file: file.id
  )
  @primary-subject(file)
  delta/file/git/status

  # Versions and Version References
  # --------------------

  @query(
    command: """
      pwd &&
    ! git rev-parse --show-toplevel &&
    ! git for-each-ref --format='%(objectname:short)|%(refname:short)|%(HEAD)|%(objecttype)|%(objectname:short)|%(objectname)|%(*objectname:short)|%(*objectname)|%(taggername)|%(taggeremail:trim)|%(taggerdate:iso-local)|%(*authorname)|%(*authoremail:trim)|%(*authordate:iso-local)|%(*committername)|%(*committeremail:trim)|%(*committerdate:iso-local)|%(authorname)|%(authoremail:trim)|%(authordate:iso-local)|%(committername)|%(committeremail:trim)|%(committerdate:iso-local)' refs/tags &&
    ! git for-each-ref --format='%(contents:subject)==========' refs/tags &&
    ! git for-each-ref --format='%(contents:body)==========' refs/tags &&
    ! git for-each-ref --format='%(trailers:only)==========' refs/tags &&
    ! git for-each-ref --format='%(contents:signature)==========' refs/tags &&
    ! git for-each-ref --format='%(*contents:subject)==========' refs/tags &&
    ! git for-each-ref --format='%(*contents:body)==========' refs/tags &&
    ! git for-each-ref --format='%(*trailers:only)==========' refs/tags &&
    ! git for-each-ref --format='%(*contents:signature)==========' refs/tags
    """
    parse: """
      [
        .[0].stdout,
        (if .[1].status == 0 then .[1].stdout else null end)
      ] as [
        $dirPath,
        $repoPath
      ]
      | [
        [
          (.[2].stdout | split("\n")),
          [.[3].stdout | split("==========")[:-1][] | gsub("^\\s+|\\s+$";"")],
          [.[4].stdout | split("==========")[:-1][] | gsub("^\\s+|\\s+$";"")],
          [.[5].stdout | split("==========")[:-1][] | gsub("^\\s+|\\s+$";"")],
          [.[6].stdout | split("==========")[:-1][] | gsub("^\\s+|\\s+$";"")],
          [.[7].stdout | split("==========")[:-1][] | gsub("^\\s+|\\s+$";"")],
          [.[8].stdout | split("==========")[:-1][] | gsub("^\\s+|\\s+$";"")],
          [.[9].stdout | split("==========")[:-1][] | gsub("^\\s+|\\s+$";"")],
          [.[10].stdout | split("==========")[:-1][] | gsub("^\\s+|\\s+$";"")]
        ]
        | transpose[] as [
          $coreInfo,
          $subject, $body, $trailers, $signature,
          $peeledSubject, $peeledBody, $peeledTrailers, $peeledSignature
        ]
        | $coreInfo
        | split("|")
        | {
          "version.id":            (.[0]),
          "version.ref.id":        (.[1]),

          # Even if .[2] == "+", then it is still not in this dir (dir.id) or repo (repo.id)
          "version.ref.isCurrent": (.[2] == "*")
        } + (
          if .[3] == "tag" then {
            "version.ref.obj.id":        (.[4]),
            "version.ref.obj.id.full":   (.[5]),
            "version.ref.author.name":   (.[8]),
            "version.ref.author.email":  (.[9]),
            "version.ref.authored.date": (.[10]),
            "version.ref.summary":       ($subject),
            "version.ref.description":   (if $body != "" then $body else null end),
            "version.ref.footers":       ($trailers | split("\n")),
            "version.ref.signature":     (if $signature != "" then $signature else null end),

            "version.id":                (.[6]),
            "version.id.full":           (.[7]),
            "version.author.name":       (.[11]),
            "version.author.email":      (.[12]),
            "version.authored.date":     (.[13]),
            "version.creator.name":      (.[14]),
            "version.creator.email":     (.[15]),
            "version.created.date":      (.[16]),
            "version.summary":           ($peeledSubject),
            "version.description":       (if $peeledBody != "" then $peeledBody else null end),
            "version.footers":           ($peeledTrailers | split("\n")),
            "version.signature":         (if $peeledSignature != "" then $peeledSignature else null end)
          } else {
            "version.id":            (.[4]),
            "version.id.full":       (.[5]),
            "version.author.name":   (.[17]),
            "version.author.email":  (.[18]),
            "version.authored.date": (.[19]),
            "version.creator.name":  (.[20]),
            "version.creator.email": (.[21]),
            "version.created.date":  (.[22]),
            "version.summary":       ($subject),
            "version.description":   (if $body != "" then $body else null end),
            "version.footers":       ($trailers | split("\n")),
            "version.signature":     (if $signature != "" then $signature else null end)
          } end
        )
      ]
      | map(
        {
          "dir.id": ($dirPath),
          "repo.id": ($repoPath)
        } + .
      )
    """
  )
  @subjects(
    dir: dir.id
    repo: repo.id
    version: version.id
    version/ref: version.ref.id
  )
  @primary-subject(version/ref)
  version/ref/git/tag

  @query(
    command: """
      pwd &&
    ! git rev-parse --show-toplevel &&
    ! git for-each-ref --format='%(objectname:short)|%(refname:short)|%(upstream:short)|%(HEAD)|%(upstream:track,nobracket)|%(objectname)|%(authorname)|%(authoremail:trim)|%(authordate:iso-local)|%(committername)|%(committeremail:trim)|%(committerdate:iso-local)' refs/heads &&
    ! git for-each-ref --format='%(contents:subject)==========' refs/heads &&
    ! git for-each-ref --format='%(contents:body)==========' refs/heads &&
    ! git for-each-ref --format='%(trailers:only)==========' refs/heads &&
    ! git for-each-ref --format='%(contents:signature)==========' refs/heads
    """
    parse: """
      [
        .[0].stdout,
        (if .[1].status == 0 then .[1].stdout else null end)
      ] as [
        $dirPath,
        $repoPath
      ]
      | [
        [
          (.[2].stdout | split("\n")),
          [.[3].stdout | split("==========")[:-1][] | gsub("^\\s+|\\s+$";"")],
          [.[4].stdout | split("==========")[:-1][] | gsub("^\\s+|\\s+$";"")],
          [.[5].stdout | split("==========")[:-1][] | gsub("^\\s+|\\s+$";"")],
          [.[6].stdout | split("==========")[:-1][] | gsub("^\\s+|\\s+$";"")]
        ]
        | transpose[] as [$coreInfo, $subject, $body, $trailers, $signature]
        | $coreInfo
        | split("|")
        | {
          "version.id":            (.[0]),
          "version.ref.id":        (.[1]),
          "version.ref.remote.id": (.[2]),

          # Even if .[3] == "+", then it is still not in this dir (dir.id) or repo (repo.id)
          "version.ref.isCurrent": (.[3] == "*"),
          "version.ref.ahead.remote":  (
            .[4]
            | sub("^(ahead (?<ahead>[0-9]*))?(, )?(behind (?<behind>[0-9]*))?$";"\(.ahead)")
            | if . != "" and . != "null" then tonumber else 0 end
          ),
          "version.ref.behind.remote": (
            .[4]
            | sub("^(ahead (?<ahead>[0-9]*))?(, )?(behind (?<behind>[0-9]*))?$";"\(.behind)")
            | if . != "" and . != "null" then tonumber else 0 end
          ),

          "version.id.full":       (.[5]),
          "version.author.name":   (.[6]),
          "version.author.email":  (.[7]),
          "version.authored.date": (.[8]),
          "version.creator.name":  (.[9]),
          "version.creator.email": (.[10]),
          "version.created.date":  (.[11]),
          "version.summary":       ($subject),
          "version.description":   (if $body != "" then $body else null end),
          "version.footers":       ($trailers | split("\n")),
          "version.signature":     (if $signature != "" then $signature else null end)
        }
      ]
      | map(
        {
          "dir.id": ($dirPath),
          "repo.id": ($repoPath)
        } + .
      )
    """
  )
  @subjects(
    dir: dir.id
    repo: repo.id
    version: version.id
    version/ref: version.ref.id
  )
  @primary-subject(version/ref)
  version/ref/git/branch

  # Specific Entities
  # --------------------

  @query(
    command: """
      pwd &&
    ! git rev-parse --show-toplevel &&
    ! git rev-parse --short HEAD &&
    ! git rev-parse HEAD
    """
    parse: """
      [{
        "dir.id":     (.[0].stdout),
        "repo.id":    (if .[1].status == 0 then .[1].stdout else null end),
        "version.id": (if .[2].status == 0 then .[2].stdout else null end),

        "version.id.full": (if .[3].status == 0 then .[3].stdout else null end)
      }]
    """
  )
  @subjects(
    dir: dir.id
    repo: repo.id
    version: version.id
  )
  @primary-subject(version)
  version/current/git

  @query(
    command: """
      pwd &&
    ! git rev-parse --show-toplevel &&
    ! git symbolic-ref --short -q HEAD &&
    - info.query(version/ref/git/branch) :: $
    """
    parse: """
      [
        {
          "dir.id":         (.[0].stdout),
          "repo.id":        (if .[1].status == 0 then .[1].stdout else null end),
          "version.ref.id": (if .[2].status == 0 and .[2].stdout != "" then .[2].stdout else null end)
        } + (
          [.[3].stdout, .[2].stdout] as [$branches, $curBranch]
          | if .[2].status == 0 and $curBranch != "" then $branches[$curBranch] else {} end
        )
      ]
    """
  )
  @subjects(
    dir: dir.id
    repo: repo.id
    version/ref: version.ref.id
  )
  @primary-subject(version/ref)
  version/ref/current/git/branch

  @query(
    command: """
      pwd &&
    ! git rev-parse --show-toplevel &&
    ! git describe --tags --exact-match
    """
    parse: """
      [{
        "dir.id":         (.[0].stdout),
        "repo.id":        (if .[1].status == 0 then .[1].stdout else null end),
        "version.ref.id": (if .[2].status == 0 and .[2].stdout != "" then .[2].stdout else null end)
      }]
    """
  )
  @subjects(
    dir: dir.id
    repo: repo.id
    version/ref: version.ref.id
  )
  @primary-subject(version/ref)
  version/ref/current/git/tag

  @query(
    command: """
      pwd &&
    ! git rev-parse --show-toplevel &&
    ! git rev-list --tags --max-count=1 --pretty=format:'%h' &&
    ! git rev-list --tags --max-count=1 --pretty=format:'%D' &&
    ! git for-each-ref refs/tags --sort=-creatordate --format='%(objectname:short)' --count=1 &&
    ! git for-each-ref refs/tags --sort=-creatordate --format='%(refname:short)' --count=1
    """
    parse: """
      (
        if .[3].status == 0 and .[3].stdout != "" then [
          [.[0], .[1], .[2], .[3]] as [$_0, $_1, $_2, $_3]
          | .[3].stdout
          | split("\n")[1]
          | split(", ")[]
          | select(startswith("tag: "))
          | sub("^tag: ";"")
          | {
            "dir.id":         ($_0.stdout),
            "repo.id":        (if $_1.status == 0 then $_1.stdout else null end),
            "version.id":     (if $_2.status == 0 and $_2.stdout != "" then $_2.stdout | split("\n")[1] else null end),
            "version.ref.id": (.),

            "version.ref.isOrderedLast": (true)
          }
        ] else [] end
      ) + (
        if .[5].status == 0 and .[5].stdout != "" then [
          {
            "dir.id":         (.[0].stdout),
            "repo.id":        (if .[1].status == 0 then .[1].stdout else null end),
            "version.id":     (if .[4].status == 0 and .[4].stdout != "" then .[4].stdout else null end),
            "version.ref.id": (.[5].stdout),

            "version.ref.isCreatedLast": (true)
          }
        ] else [] end
      )
    """
  )
  @subjects(
    dir: dir.id
    repo: repo.id
    version/ref: version.ref.id
  )
  @primary-subject(version/ref)
  version/ref/latest/git/tag

  #"""
    TODO
    --------------------

    - See: https://git-scm.com/docs/giteveryday

    # Info for refs
    # ----------

    # DONE
    git for-each-ref --format='%(HEAD)|%(refname:short)|%(objectname)|%(objectname:short)|%(upstream:track,nobracket)|%(authorname)|%(authoremail:trim)|%(authordate:iso-local)|%(committername)|%(committeremail:trim)|%(committerdate:iso-local)' refs/heads
    git for-each-ref --format='%(contents:subject)' refs/heads
    git for-each-ref --format='%(contents:body)' refs/heads
    git for-each-ref --format='%(trailers:only)' refs/heads
    git for-each-ref --format='%(contents:signature)' refs/heads
      - refname:short [PKEY]    -> version.ref.id
      - objectname:short [FKEY] -> version.id (commit this branch references)
      - upstream [FKEY]         -> version.ref.remote.id (remote branch that this branch is tracking)

    git for-each-ref --format='%(HEAD)|%(refname:short)|%(objecttype)|%(objectname)|%(objectname:short)|%(*objectname)|%(*objectname:short)|%(taggername)|%(taggeremail:trim)|%(taggerdate:iso-local)|%(*authorname)|%(*authoremail:trim)|%(*authordate:iso-local)|%(*committername)|%(*committeremail:trim)|%(*committerdate:iso-local)|%(authorname)|%(authoremail:trim)|%(authordate:iso-local)|%(committername)|%(committeremail:trim)|%(committerdate:iso-local)' refs/tags
    git for-each-ref --format='%(contents:subject)' refs/tags
    git for-each-ref --format='%(contents:body)' refs/tags
    git for-each-ref --format='%(trailers:only)' refs/tags
    git for-each-ref --format='%(contents:signature)' refs/tags
    git for-each-ref --format='%(*contents:subject)' refs/tags
    git for-each-ref --format='%(*contents:body)' refs/tags
    git for-each-ref --format='%(*trailers:only)' refs/tags
    git for-each-ref --format='%(*contents:signature)' refs/tags
      - refname:short [PKEY]                                  -> version.ref.id
      [IF]
        - objecttype                                          -> annotated ("tag") or lightweight ("commit") tag?
      [is annotated; THEN]
        - objectname... + *objectname...                      -> version.ref.obj.id[.full] + version.id[.full] [*objectname:short = FKEY]
        - tagger... + *author... + *committer...              -> version.ref.author... + version.author.* + version.creator.*
        - contents.../trailers... + *contents.../*trailers... -> version.ref.* + version.*
      [is lightweight; THEN]
        - objectname...                                       -> version.id[.full] [objectname:short = FKEY]
        - author... + committer...                            -> version.author.* + version.creator.*
        - contents.../trailers...                             -> version.*

    # TODO
    git for-each-ref --format='%(HEAD)|%(refname:short)|%(objectname)|%(objectname:short)|%(authorname)|%(authoremail:trim)|%(authordate:iso-local)|%(committername)|%(committeremail:trim)|%(committerdate:iso-local)' refs/remotes
    git for-each-ref --format='%(contents:subject)' refs/remotes
    git for-each-ref --format='%(contents:body)' refs/remotes
    git for-each-ref --format='%(trailers:only)' refs/remotes
    git for-each-ref --format='%(contents:signature)' refs/remotes
      - refname:short [PKEY]    -> version.ref.remote.id
      - objectname:short [FKEY] -> version.ref.remote.commit.id (commit this remote tracking branch references)

    git for-each-ref --format='%(refname:short)|%(objectname)|%(objectname:short)' refs/stash
      - refname:short [PKEY] -> git.stash.id
      - objectname:short [FKEY] -> git.stash.commit.id

    # Write/Modify Commands (workflow)
    # ----------

    # Might require `--no-optional-locks`, ie. don't write things you don't need to

    git clone $remote_url $local_path
    git fetch -p
    git fetch --tags -f

    git branch $branch $source_ref
    git branch -m # rename branch
    git branch --unset-upstream
    git branch -d/-D # delete / force-delete branch

    # Stash changes
    git stash --include-untracked # normal stash + unstaged, non-ignored files
    git stash --all # stash EVERYTHING
    git stash pop --index # Re-stage changes that were staged before stash

    # Change branch
    git checkout
    + git submodule update # stash? "would be overridden by checkout"?

    git rebase origin/$branch
    git rebase -i $default_branch
    git rebase --abort

    git push --force-with-lease
    git push origin :$branch

    # TODO:
    # - update all (active) branches, not just the current branch
    # - cache entries should include the data they were created, so:
    #   - they can be invalidated by time
    #   - they can be set incrementally (ie. extended)
    # - keep history of branches?
    #   - eg. after deletion, which commit was the branch at? for destroying infra
    # - categorise branches and tags
    # - categorise MRs/PRs on the remote(s), eg. origin

    # Requires Parameters
    # ----------

    # git info format
    #project | default_branch | D^< >D< >C< >C^ | num_branches | orphans

    # Branch exists?
    git rev-parse --verify $branch

    # Get tracking branch
    branch_ref=refs/heads/$branch
    git for-each-ref --format='%(upstream:short)' $branch_ref

    # How many commits from one branch to another
    git rev-list --count $from_branch..$to_branch

    # Conventional stuff, like:
    git log --format='%s' $branch_ref | grep "^[^(]*\($type\): "

    # Remote tracking branch exists
    git ls-remote --heads origin $branch_ref

    # get ref of commit ID
    git describe --tags $commit_id

    # Get author date of commit at $ref
    git log --date=format:%Y-%m-%d --pretty=format:%ad $ref

    # Get formatted log of commit
    git log -1 format=$format $ref

    # Format every ref (eg. for getting branches with some patterns filtered out)
    git for-each-ref --format=$format refs/heads
  """
}

# Categories
# ----------------------------------------------------------------------------------------------------

artifact   [package | host-image]
deployment [installation | instance]

category/hardware [command & [hardware]]
category/storage  [command & [filesystem | file | dir]]
category/projects [command & [source | artifact | deployment | configuration]]

}
